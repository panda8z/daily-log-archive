

# MySQL索引





数据库系统还维护着满足特定查找算法的数据结构。这种数据就是索引。





## 2.1 MySQL遇到的问题：性能下降SQL慢 

- 执行时间长 

-  等待时间长

- - 查询语句写的烂

  - 索引失效

  - - 单值
    - 复合

  - 关联查询太多join(设计缺陷或不得已的需求)

  - 服务器调优及各个参数设置(缓冲\线程数等)

```mysql
show databases;
use db2020;
select * from db2020;
create index idx_user_name user(name);
```

## 2.2 解决方案：常见通用的join查询

- - SQL执行顺序

- - - 手写

      ```sql
      # 手写顺序
      SELECT DISTINCT <select_list>
      FROM <left_table> <join_type> 
      JOIN <right_table> ON <join_condition>
      WHERE <where_condition>
      GROUP BY <group_by_list>
      HAVING <having_condition>
      ORDER BY <order_by_condition>
      LIMIT <limit_number>
      ```

      

    - 机读

      ```sql
       
        FROM <left_table> 
        ON <join_condition> <join_type> JOIN <right_table> 
        WHERE <where_condition>
        GROUP BY <group_by_list>
        HAVING <having_condition>
        SELECT 
        DISTINCT <select_list>
        ORDER BY <order_by_condition>
        LIMIT <limit_number>
      ```

        

    - 总结

  - Join图

  - 建表SQL

  - 7种Join

    - Inner join 只有共有部分。
    - left join  左边独有 + 共有。
    - right join 共有 + 右边独有。
    - left join  where R.key is null 只有左独有。
    - right join where L.key is null 只有右独有。
    - full outer join 左右合集 mysql 不支持。

## 2.3 解决方案：索引简介

### 2.3.1 索引是什么

- - MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。
- 可以得到索引的本质：索引是数据结构
  - 你可以简单理解为"排好序的快速查找数据结构"。
- - 详解(重要)
    - 结论
    - 数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，
      - 这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。
  - 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上
  - 我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，
  - 复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。

### 2.3.2 索引的优劣

- 优势

- - 类似大学图书馆建书目索引，**提高数据检索效率，降低数据库的IO成本**
  - 通过索引列对数据进行排序，**降低数据排序成本，降低了CPU的消耗**

- 劣势

- - 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以**索引列也是要占用空间的**。
  
  - 虽然索引大大提高了查询速度，同时却会**降低更新表的速度**,如果对表INSERT,UPDATE和DELETE。
  
  - 因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段。

  - 都会调整因为更新所带来的键值变化后的索引信息
  
  - **索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句**
  
### 2.3.3 mysql索引分类

  - **单值索引**
  
    即一个索引只包含单个列，一个表可以有多个单列索引
  
  - **唯一索引**
  
    索引列的值必须唯一，但允许有空值
  
  - **复合索引**
  
    即一个索引包含多个列
  
  - 基本语法
  
    - 创建
    
      ```sql
      CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
      ```
    
      如果是CHAR,VARCHAR类型，length可以小于字段实际长度；
    
      如果是BLOB和TEXT类型，必须指定length。
    
      ```sql
      ALTER mytable ADD [UNIQUE] INDEX [indexName] ON(columnname(length));
      ```
    
    - 删除
    
      ```sql
      DROP INDEX [indexName] ON mytable;
      ```
    
    - 查看
    
      ```sql
      SHOW INDEX FROM table_name\G
      ```
    
      
    
    - 使用ALTER命令

### 2.3.4 MySQL常用索引结构

  - **B+Tree索引**
  
    - 检索原理
    
      ![image-20200923093939214](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0c5w8oeqj318y0le1hn.jpg)
    
      #### 【初始化介绍】
    
       一颗 B+ 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色
    
      所示)，
    
      如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3。
      P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。
    
      真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 
    
      非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。
    
      #### 【查找过程】
    
       如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO。
    
      在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短(相比磁盘的 IO)可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO。
    
      29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 IO。
    
      同时内存中做二分查找找到 29，结束查询，总计三次 IO。
    
      
    
      真实的情况是，3 层的 B+树可以表示上百万的数据。
    
      如果上百万的数据查找只需要三次 IO，性能提高将是巨大的。
      如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。
  
  - **Hash索引**
  
  - **full-text全文索引**
  
  - **R-Tree索引**

### 2.3.5 建立索引的一些原则

- 哪些情况需要创建索引

  1. 主键自动建立唯一索引
  2. 频繁作为查询的条件的字段应该创建索引
  3. 查询中与其他表关联的字段，外键关系建立索引
  4. 频繁更新的字段不适合创建索引。因为每次更新不单单是更新了记录还会更新索引，加重IO负担。
  5. Where条件里用不到的字段不创建索引
  6. 单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）
  7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度
  8. 查询中统计或者分组字段

- 哪些情况不要创建索引

  1. 表记录太少
  2. 经常增删改的表
  3. 数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。

## B+Tree 与 B-Tree 的区别 

### 区别

B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息;
B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。

在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在;
而 B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。

### 哪个更适合MySQL？

从这个角度看 B- 树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。

因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。

尽管 B+树找到 一个记录所需的比较次数要比 B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些。

而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历(例如查看一个目录下的所有 文件，一个表中的所有记录等)，这也是很多数据库和文件系统使用 B+树的缘故。

> 思考: 为什么说 B+ 树比 B- 树更适合实际应用中操作系统的文件索引和数据库索引? 

####  B+树的磁盘读写代价更低

B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就 越多。相对来说 IO 读写次数也就降低了。

####   B+树的查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须 走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## 聚簇索引和非聚簇索引 

### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储

在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。

![image-20200923163655069](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj0o846jeej30os0hen2d.jpg)

### 聚簇索引的好处: 

按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的 io 操作。

### 聚簇索引的限制:

对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 Myisam 并不支持聚簇索引。 由于数据物理存储排序方式只能有一种，所以每个 Mysql 的表只能有一个聚簇索引。一般情况下就是 该表的主键。

为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用 无序的 id，比如 uuid 这种。

## 索引的优化



