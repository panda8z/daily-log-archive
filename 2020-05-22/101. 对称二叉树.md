# 101.对称二叉树-如何理解递归？详细图解



## 递归法

一般树相关的题用递归都非常容易理解，但是很多时候，这个很好理解是在看到代码后...
所以在做了一些树相关的题后，在这里就讲一下我对树结构中递归的理解，供大家参考。

- 递归的本质是什么呢？简单说： **大问题** -> 若干 **规模更小** 且 **结构相同** 的 **小问题**
  - 那么我们只要抓住两个核心： `1) 规模更小（分治）`；`2) 结构相同（共性）`
- 由于树结构本身就具有`分治`的特性，因为树结构的父子关系; （下文有详细解释）
- 所以我们需要做的就是找`共性`，而所谓的共性就是：**满足相同的规律**

### 分析

就本题而言，我们看下图：
在这样一个对称的二叉树中，图 (a)，(c)，(d) 中的蓝色节点部分就是我们要寻找的`共性`

首先看图 (a)，由于对称，所以在这个区域内，保持这样一个`规律`（共性）：

1. **两个父节点的值相等**: left.val == right.val*l**e**f**t*.*v**a**l*==*r**i**g**h**t*.*v**a**l*
2. **左父亲的右子的值** == **右父亲的左子的值**： left.right \ == right.left*l**e**f**t*.*r**i**g**h**t* ==*r**i**g**h**t*.*l**e**f**t*
3. **左父亲的左子的值** == **右父亲的右子的值**： left.left \ \ \ == right.right*l**e**f**t*.*l**e**f**t*  ==*r**i**g**h**t*.*r**i**g**h**t*

大家看(c)、(d) 的蓝色节点部分，是不是和上面的树的蓝色节点部分保持了相同的规律；
![图片.png](/Users/zcj/panda/git4me/daily-log-archive/2020-05-22/101. 对称二叉树/ff74f26781a4eff54e414a6716578a44ed20e862450ecc3f54dfbd3ef0d86efb-图片.png)

好，现在我们已经找到了规律，接下来就是重点，**如何理解树本身的分治特性？即如何找到子问题呢？**

> 我以前刚接触 树 的题，以为的树中递归划分子问题是，直接将当前这个结构传递给其子结构。就这个题而言，我们已经找到了具有共性的结构，即图(a)中蓝色的部分，那么按我之前的理解，递归的下一层就是`left(2)` 和 `right(2)`节点的左右子节点，即` 3`，`4` 节点及其子节点构成的结构；很明显，这么来思考我们会得出错误的结论，即 `3`，`4` 两颗子树构成的子结构并不对称！

而正确的思考方式是图(b), 不要把图 (a)的蓝色部分当做整个树的**一个部分**，而是把这个结构当做**整个树的抽象**！

> - 我们抽取的这个具有共性的结构，其实就是这个树本身；
> - 而我们提取的这个规律，在这个树的任意一个子结构都满足！
> - 这里的子结构就是 `3`,`4`,`4`,`3` 四颗子树;
> - 其中最关键的递归逻辑就是： 判断父结构满足规律的前提是所有子结构全部满足

再举个简单的例子：
我现在要完成一个任务，由于我非常懒，于是我就把这个任务分成两个部分，分别交个`A`, `B`去完成
谁料到`A`，`B` 也特别懒，`A`把任务也对半分，交给了` A1`,`A2` ; `B` 也把任务对半分，交给了 `B1`,`B2`
所以我的这个事的完成取决于： `A1`，`A2`，`B1`，`B2` 四个人完成任务后，我的任务才算做完了

有了以上的铺垫，我们再去看下面的代码，checkSymetry()*c**h**e**c**k**S**y**m**e**t**r**y*() 方法就是用来验证上述规律的三条

1. **两个父节点的值相等**: left.val == right.val*l**e**f**t*.*v**a**l*==*r**i**g**h**t*.*v**a**l*
2. **左父亲的右子\*的值** == **右父亲的左子\*的值**： left.right \ == right.left*l**e**f**t*.*r**i**g**h**t* ==*r**i**g**h**t*.*l**e**f**t*
3. **左父亲的左子\*的值** == **右父亲的右子\*的值**： left.left \ \ \ == right.right*l**e**f**t*.*l**e**f**t*  ==*r**i**g**h**t*.*r**i**g**h**t*

只不过我们在检查规律`2`,`3`的同时，又递归的检查的子树是否满足规律而已。**因为子树满足规律是前提！**

- checkSymetry(left.right, right.left)*c**h**e**c**k**S**y**m**e**t**r**y*(*l**e**f**t*.*r**i**g**h**t*,*r**i**g**h**t*.*l**e**f**t*)
- checkSymetry(left.left, right.right)*c**h**e**c**k**S**y**m**e**t**r**y*(*l**e**f**t*.*l**e**f**t*,*r**i**g**h**t*.*r**i**g**h**t*)

以上是我个人的理解，感谢有耐心看到这里的你们! 有问题可以评论交流指正~

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null || checkSymetry(root.left, root.right);
    }
    private boolean checkSymetry(TreeNode left, TreeNode right) {
        if (left == null && right == null) { return true; }
        if (left == null || right == null) { return false; }
        return left.val == right.val 
             && checkSymetry(left.right, right.left) 
             && checkSymetry(left.left,  right.right);
    }
}
```

