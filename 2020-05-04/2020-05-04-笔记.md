# 2020-05-04-笔记

## 今日任务

## 今天是五四青年节

B站出了个《后浪》演讲，演员何冰，和一些up主的视频剪辑。

演讲全文如下：

<article style="font-weight:900">

那些口口声声 “一代不如一代”的人

应该看看你们

就像我一样

我看着你们 满怀羡慕

人类积攒了几千年的财富

所有的知识 见识 智慧和艺术

像是专门为你们准备的礼物

科技繁荣 文化繁茂 城市繁华

现代文明的成果 被层层打开

可以尽情享用

自由学习一门语言 学习一门手艺

欣赏一部电影 去遥远的地方旅行

很多人 从小你们就在自由探索自己的兴趣

很多人在童年 就进入了不惑之年

不惑于自己喜欢什么 不喜欢什么

人与人之间的壁垒被打破

你们只凭相同的爱好 就能结交千万个值得干杯的朋友

你们拥有了 我们曾经梦寐以求的权利

选择的权利

你所热爱的 就是你的生活

你们有幸 遇见这样的时代

但是时代更有幸 遇见这样的你们

我看着你们 满怀敬意

向你们的专业态度致敬

你们正在把传统的 变成现代的

把经典的 变成流行的

把学术的 变成大众的

把民族的 变成世界的

你们把自己的热爱

变成了一个和成千上万的人 分享快乐的事业

向你们的自信致敬

弱小的人才习惯嘲讽和否定

内心强大的人 从不吝啬赞美和鼓励

向你们的大气致敬

小人同而不和 君子美美与共 和而不同

更年轻的身体 容得下更多元的文化 审美 和价值观

有一天我终于发现 不只是我们在教你们如何生活

你们也在启发我们 怎样去更好的生活

那些抱怨“一代不如一代的人”

应该看看你们 就像我一样

我看着你们 满怀感激

因为你们 这个世界会更喜欢中国

因为一个国家最好看的风景

就是这个国家的年轻人

因为你们 这世上的小说 音乐 电影中表现的青春

就不再是忧伤 迷茫

而是善良 勇敢 无私 无所畏惧

是心里有火 眼里有光

不用活成我们想象中的样子

我们这一代的想象力

不足以想象你们的未来

如果你们依然需要我们的祝福

那么

奔涌吧 后浪

我们在同一条奔涌的河流

</article>

## 分析一个库[gomarkdown/markdown: markdown parser and HTML renderer for Go](https://github.com/gomarkdown/markdown)



### 1. 启始

#### 1.1 官方给的示例

```go
md := []byte("## markdown document") // 字符串转换成字节数组
// 字节数组传送给 ToHtml 函数 返回的依然是个字节数组，string（output） 就能正常打印结果了。
output := markdown.ToHTML(md, nil, nil)
fmt.Println(string(output))
```



#### 1.2 **观察  markdown.ToHTML（）**

```go
// Parse parsers a markdown document using provided parser. If parser is nil,
// we use parser configured with parser.CommonExtensions.
//
// It returns AST (abstract syntax tree) that can be converted to another
// format using Render function.
func Parse(markdown []byte, p *parser.Parser) ast.Node {
	if p == nil {
		p = parser.New()
	}
	return p.Parse(markdown)
}
```

翻译一下注释：

**解析组件会使用指定的解析器解析 markdown 文档。如果没有指定解析器，我们默认使用公共解析器**

**Parse( ) 返回了抽象语法树，抽象语法树可以方便地被渲染器渲染成各种格式（例如 html pdf 等）**



#### 1.3 继续观察重点方法 parse.New( )

```go
// New creates a markdown parser with CommonExtensions.
//
// You can then call `doc := p.Parse(markdown)` to parse markdown document
// and `markdown.Render(doc, renderer)` to convert it to another format with
// a renderer.
func New() *Parser {
	return NewWithExtensions(CommonExtensions)
}

// NewWithExtensions creates a markdown parser with given extensions.
func NewWithExtensions(extension Extensions) *Parser {
	p := Parser{
		refs:         make(map[string]*reference),
		refsRecord:   make(map[string]struct{}),
		maxNesting:   16,
		insideLink:   false,
		Doc:          &ast.Document{},
		extensions:   extension,
		allClosed:    true,
		includeStack: newIncStack(),
	}
	p.tip = p.Doc
	p.oldTip = p.Doc
	p.lastMatchedContainer = p.Doc

	p.inlineCallback[' '] = maybeLineBreak
	p.inlineCallback['*'] = emphasis
	p.inlineCallback['_'] = emphasis
	if p.extensions&Strikethrough != 0 {
		p.inlineCallback['~'] = emphasis
	}
	p.inlineCallback['`'] = codeSpan
	p.inlineCallback['\n'] = lineBreak
	p.inlineCallback['['] = link
	p.inlineCallback['<'] = leftAngle
	p.inlineCallback['\\'] = escape
	p.inlineCallback['&'] = entity
	p.inlineCallback['!'] = maybeImage
	if p.extensions&Mmark != 0 {
		p.inlineCallback['('] = maybeShortRefOrIndex
	}
	p.inlineCallback['^'] = maybeInlineFootnoteOrSuper
	if p.extensions&Autolink != 0 {
		p.inlineCallback['h'] = maybeAutoLink
		p.inlineCallback['m'] = maybeAutoLink
		p.inlineCallback['f'] = maybeAutoLink
		p.inlineCallback['H'] = maybeAutoLink
		p.inlineCallback['M'] = maybeAutoLink
		p.inlineCallback['F'] = maybeAutoLink
	}
	if p.extensions&MathJax != 0 {
		p.inlineCallback['$'] = math
	}

	return &p
}
	
```

解释一下上面的代码：

**直接使用公用扩展创建了一个解析器，解析器包含了多个组件：行内回调，内部栈，最大嵌套层级等。**

#### 1.4 继续观察重点方法 parse.Parse( )



```go
// Parse generates AST (abstract syntax tree) representing markdown document.
//
// The result is a root of the tree whose underlying type is *ast.Document
//
// You can then convert AST to html using html.Renderer, to some other format
// using a custom renderer or transform the tree.
func (p *Parser) Parse(input []byte) ast.Node {
	p.block(input)
	// Walk the tree and finish up some of unfinished blocks
	for p.tip != nil {
		p.finalize(p.tip)
	}
	// Walk the tree again and process inline markdown in each block
	ast.WalkFunc(p.Doc, func(node ast.Node, entering bool) ast.WalkStatus {
		switch node.(type) {
		case *ast.Paragraph, *ast.Heading, *ast.TableCell:
			p.Inline(node, node.AsContainer().Content)
			node.AsContainer().Content = nil
		}
		return ast.GoToNext
	})

	if p.Opts.Flags&SkipFootnoteList == 0 {
		p.parseRefsToAST()
	}
	return p.Doc
}
```



翻译一下注释：

**解析器产生 markdown 文档的抽象语法树**

**返回结果是一个 类型是 *ast.Document 的树的根结点**