<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><style>.bespoke-marp-note,.bespoke-marp-osc,.bespoke-progress-parent{display:none;transition:none}@media screen{body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:0;color:inherit;cursor:pointer;font-size:inherit;opacity:.8;outline:none;padding:0;transition:opacity .2s linear;-webkit-tap-highlight-color:transparent}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:disabled,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:disabled,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:disabled{cursor:not-allowed;opacity:.15!important}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover{opacity:1}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:active,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:active,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover:active{opacity:.6}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:not(:disabled),body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:not(:disabled),body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover:not(:disabled){transition:none}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button.bespoke-marp-presenter-info-page-prev{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSI1IiBkPSJNNjggOTBMMjggNTBsNDAtNDAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button.bespoke-marp-presenter-info-page-next{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSI1IiBkPSJNMzIgOTBsNDAtNDAtNDAtNDAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen]{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6NXB4fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJhIiB4PSIxMCIgeT0iMjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI2MCIgcng9IjUuNjciLz48cGF0aCBjbGFzcz0iYSIgZD0iTTQwIDcwSDIwVjUwbTIwIDBMMjAgNzBtNDAtNDBoMjB2MjBtLTIwIDBsMjAtMjAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button.exit[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button.exit[data-bespoke-marp-osc=fullscreen]{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6NXB4fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJhIiB4PSIxMCIgeT0iMjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI2MCIgcng9IjUuNjciLz48cGF0aCBjbGFzcz0iYSIgZD0iTTIwIDUwaDIwdjIwbS0yMCAwbDIwLTIwbTQwIDBINjBWMzBtMjAgMEw2MCA1MCIvPjwvc3ZnPg==")}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter]{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS13aWR0aDo1cHh9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImEiIGQ9Ik0yMCA2MGgtNWE1IDUgMCAwMS01LTVWMjBhNSA1IDAgMDE1LTVoNjBhNSA1IDAgMDE1IDV2NU0zMCA4NWg2MCIvPjxyZWN0IHg9IjMwIiB5PSIzNSIgd2lkdGg9IjYwIiBoZWlnaHQ9IjQwIiByeD0iNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZmIi8+PHJlY3QgY2xhc3M9ImEiIHg9IjMwIiB5PSIzNSIgd2lkdGg9IjYwIiBoZWlnaHQ9IjQwIiByeD0iNSIvPjxwYXRoIGNsYXNzPSJhIiBkPSJNNDAgNTBoNDBNNDAgNjBoMzAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body,html{height:100%;margin:0}body{background:#000;overflow:hidden}svg.bespoke-marp-slide{opacity:0;pointer-events:none;z-index:-1}svg.bespoke-marp-slide.bespoke-marp-active{opacity:1;pointer-events:auto;z-index:0}svg.bespoke-marp-slide[data-bespoke-marp-load=hideable]{display:none}svg.bespoke-marp-slide[data-bespoke-marp-load=hideable].bespoke-marp-active{display:block}[data-bespoke-marp-fragment=inactive]{visibility:hidden}body[data-bespoke-view=""] .bespoke-marp-parent,body[data-bespoke-view=next] .bespoke-marp-parent{bottom:0;left:0;position:absolute;right:0;top:0}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc{background:rgba(0,0,0,.65);border-radius:7px;bottom:50px;color:#fff;display:block;font-family:Helvetica,Arial,sans-serif;font-size:16px;left:50%;line-height:0;opacity:1;padding:12px;position:absolute;touch-action:manipulation;transform:translateX(-50%);transition:opacity .2s linear;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap;z-index:1;will-change:transform}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>*,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>*{margin-left:6px}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>:first-child,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>:first-child{margin-left:0}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>span,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>span{opacity:.8}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>span[data-bespoke-marp-osc=page],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>span[data-bespoke-marp-osc=page]{display:inline-block;min-width:140px;text-align:center}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev]{height:32px;line-height:32px;width:32px}body[data-bespoke-view=""] .bespoke-marp-parent.bespoke-marp-inactive,body[data-bespoke-view=next] .bespoke-marp-parent.bespoke-marp-inactive{cursor:none}body[data-bespoke-view=""] .bespoke-marp-parent.bespoke-marp-inactive>.bespoke-marp-osc,body[data-bespoke-view=next] .bespoke-marp-parent.bespoke-marp-inactive>.bespoke-marp-osc{opacity:0;pointer-events:none}body[data-bespoke-view=""] svg.bespoke-marp-slide,body[data-bespoke-view=next] svg.bespoke-marp-slide{height:100%;left:0;position:absolute;top:0;width:100%}body[data-bespoke-view=""] .bespoke-progress-parent{background:#222;display:flex;height:5px;width:100%}body[data-bespoke-view=""] .bespoke-progress-parent+.bespoke-marp-parent{top:5px}body[data-bespoke-view=""] .bespoke-progress-parent .bespoke-progress-bar{flex:0 0 0;background:#0288d1;transition:flex-basis .2s cubic-bezier(0,1,1,1)}body[data-bespoke-view=next]{background:transparent}body[data-bespoke-view=presenter]{background:#161616}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container{height:100%;left:0;position:absolute;top:0;width:100%;display:grid;grid-template-columns:2fr 1fr;grid-template-rows:minmax(140px,1fr) 2fr 3em;grid-template-areas:"current next" "current note" "info    note"}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent{grid-area:current;position:relative;overflow:hidden}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent svg.bespoke-marp-slide{height:calc(100% - 40px);left:20px;position:absolute;pointer-events:none;top:20px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:calc(100% - 40px)}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent svg.bespoke-marp-slide.bespoke-marp-active{-webkit-filter:drop-shadow(0 3px 10px rgba(0,0,0,.5));filter:drop-shadow(0 3px 10px rgba(0,0,0,.5))}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container{background:#222;cursor:pointer;display:none;grid-area:next;overflow:hidden;position:relative}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container.active{display:block}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container iframe.bespoke-marp-presenter-next{background:transparent;border:0;display:block;-webkit-filter:drop-shadow(0 3px 10px rgba(0,0,0,.5));filter:drop-shadow(0 3px 10px rgba(0,0,0,.5));height:calc(100% - 40px);left:20px;position:absolute;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;top:20px;width:calc(100% - 40px)}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container{background:#222;color:#ddd;grid-area:note}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note{margin:20px;width:calc(100% - 40px);height:calc(100% - 40px);box-sizing:border-box;overflow:auto;padding-right:3px;white-space:pre-wrap;word-wrap:break-word;scrollbar-width:thin;scrollbar-color:hsla(0,0%,86.7%,.5) transparent}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar{width:6px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar-track{background:transparent}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar-thumb{background:hsla(0,0%,86.7%,.5);border-radius:6px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note:empty{pointer-events:none}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note.active{display:block}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note p:first-child{margin-top:0}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note p:last-child{margin-bottom:0}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container{align-items:center;box-sizing:border-box;color:#ddd;display:flex;flex-wrap:nowrap;grid-area:info;justify-content:center;padding:0 10px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-time,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-timer{display:block;box-sizing:border-box;padding:0 10px;white-space:nowrap;width:100%}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button{height:1.5em;line-height:1.5em;width:1.5em}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page{order:2;text-align:center}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page .bespoke-marp-presenter-info-page-text{display:inline-block;min-width:120px;text-align:center}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-time{color:#999;order:1;text-align:left}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-timer{color:#999;order:3;text-align:right}}@media print{.bespoke-marp-presenter-info-container,.bespoke-marp-presenter-next-container,.bespoke-marp-presenter-note-container{display:none}}</style><style>div#p>svg>foreignObject>section{width:1280px;height:720px;box-sizing:border-box;overflow:hidden;position:relative;scroll-snap-align:center center}div#p>svg>foreignObject>section:after{bottom:0;content:attr(data-marpit-pagination);padding:inherit;pointer-events:none;position:absolute;right:0}div#p>svg>foreignObject>section:not([data-marpit-pagination]):after{display:none}/* Normalization */div#p>svg>foreignObject>section h1{font-size:2em;margin:0.67em 0}div#p>svg>foreignObject>section video::-webkit-media-controls{will-change:transform}@page{size:1280px 720px;margin:0}@media print{body,html{background-color:#fff;margin:0;page-break-inside:avoid;break-inside:avoid-page}div#p>svg>foreignObject>section{page-break-before:always;break-before:page}div#p>svg>foreignObject>section,div#p>svg>foreignObject>section *{-webkit-print-color-adjust:exact!important;color-adjust:exact!important}div#p>svg[data-marpit-svg]{display:block;height:100vh;width:100vw}}div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{display:block;height:auto;width:100%}@supports (-ms-ime-align:auto){div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{position:static}}div#p>svg>foreignObject>section svg[data-marp-fitting=svg].__reflow__{content:""}@supports (-ms-ime-align:auto){div#p>svg>foreignObject>section svg[data-marp-fitting=svg].__reflow__{position:relative}}div#p>svg>foreignObject>section [data-marp-fitting-svg-content]{display:table;white-space:nowrap}div#p>svg>foreignObject>section [data-marp-fitting-svg-content-wrap]{white-space:pre}div#p>svg>foreignObject>section img[data-marp-twemoji]{background:transparent;height:1em;margin:0 .05em 0 .1em;vertical-align:-.1em;width:1em}
/*!
 * Marp default theme.
 *
 * @theme default
 * @author Yuki Hattori
 *
 * @auto-scaling true
 * @size 4:3 960px 720px
 */div#p>svg>foreignObject>section .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}div#p>svg>foreignObject>section .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}div#p>svg>foreignObject>section .anchor:focus{outline:none}div#p>svg>foreignObject>section h1 .octicon-link,div#p>svg>foreignObject>section h2 .octicon-link,div#p>svg>foreignObject>section h3 .octicon-link,div#p>svg>foreignObject>section h4 .octicon-link,div#p>svg>foreignObject>section h5 .octicon-link,div#p>svg>foreignObject>section h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}div#p>svg>foreignObject>section h1:hover .anchor,div#p>svg>foreignObject>section h2:hover .anchor,div#p>svg>foreignObject>section h3:hover .anchor,div#p>svg>foreignObject>section h4:hover .anchor,div#p>svg>foreignObject>section h5:hover .anchor,div#p>svg>foreignObject>section h6:hover .anchor{text-decoration:none}div#p>svg>foreignObject>section h1:hover .anchor .octicon-link,div#p>svg>foreignObject>section h2:hover .anchor .octicon-link,div#p>svg>foreignObject>section h3:hover .anchor .octicon-link,div#p>svg>foreignObject>section h4:hover .anchor .octicon-link,div#p>svg>foreignObject>section h5:hover .anchor .octicon-link,div#p>svg>foreignObject>section h6:hover .anchor .octicon-link{visibility:visible}div#p>svg>foreignObject>section h1:hover .anchor .octicon-link:before,div#p>svg>foreignObject>section h2:hover .anchor .octicon-link:before,div#p>svg>foreignObject>section h3:hover .anchor .octicon-link:before,div#p>svg>foreignObject>section h4:hover .anchor .octicon-link:before,div#p>svg>foreignObject>section h5:hover .anchor .octicon-link:before,div#p>svg>foreignObject>section h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z'/%3E%3C/svg%3E")}div#p>svg>foreignObject>section{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word}div#p>svg>foreignObject>section details{display:block}div#p>svg>foreignObject>section summary{display:list-item}div#p>svg>foreignObject>section a{background-color:initial}div#p>svg>foreignObject>section a:active,div#p>svg>foreignObject>section a:hover{outline-width:0}div#p>svg>foreignObject>section strong{font-weight:inherit;font-weight:bolder}div#p>svg>foreignObject>section h1{margin:.67em 0}div#p>svg>foreignObject>section img{border-style:none}div#p>svg>foreignObject>section code,div#p>svg>foreignObject>section kbd,div#p>svg>foreignObject>section pre{font-family:monospace,monospace;font-size:1em}div#p>svg>foreignObject>section hr{box-sizing:initial;overflow:visible}div#p>svg>foreignObject>section input{font:inherit;margin:0;overflow:visible}div#p>svg>foreignObject>section [type=checkbox]{padding:0}div#p>svg>foreignObject>section *,div#p>svg>foreignObject>section [type=checkbox]{box-sizing:border-box}div#p>svg>foreignObject>section input{font-family:inherit;font-size:inherit;line-height:inherit}div#p>svg>foreignObject>section a{color:#0366d6;text-decoration:none}div#p>svg>foreignObject>section a:hover{text-decoration:underline}div#p>svg>foreignObject>section strong{font-weight:600}div#p>svg>foreignObject>section hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border-bottom:1px solid #dfe2e5}div#p>svg>foreignObject>section hr:after,div#p>svg>foreignObject>section hr:before{display:table;content:""}div#p>svg>foreignObject>section hr:after{clear:both}div#p>svg>foreignObject>section table{border-spacing:0;border-collapse:collapse}div#p>svg>foreignObject>section td,div#p>svg>foreignObject>section th{padding:0}div#p>svg>foreignObject>section details summary{cursor:pointer}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2,div#p>svg>foreignObject>section h3,div#p>svg>foreignObject>section h4,div#p>svg>foreignObject>section h5,div#p>svg>foreignObject>section h6{margin-top:0;margin-bottom:0}div#p>svg>foreignObject>section h1{font-size:32px}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2{font-weight:600}div#p>svg>foreignObject>section h2{font-size:24px}div#p>svg>foreignObject>section h3{font-size:20px}div#p>svg>foreignObject>section h3,div#p>svg>foreignObject>section h4{font-weight:600}div#p>svg>foreignObject>section h4{font-size:16px}div#p>svg>foreignObject>section h5{font-size:14px}div#p>svg>foreignObject>section h5,div#p>svg>foreignObject>section h6{font-weight:600}div#p>svg>foreignObject>section h6{font-size:12px}div#p>svg>foreignObject>section p{margin-top:0;margin-bottom:10px}div#p>svg>foreignObject>section blockquote{margin:0}div#p>svg>foreignObject>section ol,div#p>svg>foreignObject>section ul{padding-left:0;margin-top:0;margin-bottom:0}div#p>svg>foreignObject>section ol ol,div#p>svg>foreignObject>section ul ol{list-style-type:lower-roman}div#p>svg>foreignObject>section ol ol ol,div#p>svg>foreignObject>section ol ul ol,div#p>svg>foreignObject>section ul ol ol,div#p>svg>foreignObject>section ul ul ol{list-style-type:lower-alpha}div#p>svg>foreignObject>section dd{margin-left:0}div#p>svg>foreignObject>section code,div#p>svg>foreignObject>section pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}div#p>svg>foreignObject>section pre{margin-top:0;margin-bottom:0}div#p>svg>foreignObject>section input::-webkit-inner-spin-button,div#p>svg>foreignObject>section input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}div#p>svg>foreignObject>section :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}div#p>svg>foreignObject>section .border{border:1px solid #e1e4e8!important}div#p>svg>foreignObject>section .border-0{border:0!important}div#p>svg>foreignObject>section .border-bottom{border-bottom:1px solid #e1e4e8!important}div#p>svg>foreignObject>section .rounded-1{border-radius:3px!important}div#p>svg>foreignObject>section .bg-white{background-color:#fff!important}div#p>svg>foreignObject>section .bg-gray-light{background-color:#fafbfc!important}div#p>svg>foreignObject>section .text-gray-light{color:#6a737d!important}div#p>svg>foreignObject>section .pl-3,div#p>svg>foreignObject>section .px-3{padding-left:16px!important}div#p>svg>foreignObject>section .px-3{padding-right:16px!important}div#p>svg>foreignObject>section .f6{font-size:12px!important}div#p>svg>foreignObject>section .lh-condensed{line-height:1.25!important}div#p>svg>foreignObject>section .text-bold{font-weight:600!important}div#p>svg>foreignObject>section .pl-c{color:#6a737d}div#p>svg>foreignObject>section .pl-c1,div#p>svg>foreignObject>section .pl-s .pl-v{color:#005cc5}div#p>svg>foreignObject>section .pl-e,div#p>svg>foreignObject>section .pl-en{color:#6f42c1}div#p>svg>foreignObject>section .pl-s .pl-s1,div#p>svg>foreignObject>section .pl-smi{color:#24292e}div#p>svg>foreignObject>section .pl-ent{color:#22863a}div#p>svg>foreignObject>section .pl-k{color:#d73a49}div#p>svg>foreignObject>section .pl-pds,div#p>svg>foreignObject>section .pl-s,div#p>svg>foreignObject>section .pl-s .pl-pse .pl-s1,div#p>svg>foreignObject>section .pl-sr,div#p>svg>foreignObject>section .pl-sr .pl-cce,div#p>svg>foreignObject>section .pl-sr .pl-sra,div#p>svg>foreignObject>section .pl-sr .pl-sre{color:#032f62}div#p>svg>foreignObject>section .pl-smw,div#p>svg>foreignObject>section .pl-v{color:#e36209}div#p>svg>foreignObject>section .pl-bu{color:#b31d28}div#p>svg>foreignObject>section .pl-ii{color:#fafbfc;background-color:#b31d28}div#p>svg>foreignObject>section .pl-c2{color:#fafbfc;background-color:#d73a49}div#p>svg>foreignObject>section .pl-c2:before{content:"^M"}div#p>svg>foreignObject>section .pl-sr .pl-cce{font-weight:700;color:#22863a}div#p>svg>foreignObject>section .pl-ml{color:#735c0f}div#p>svg>foreignObject>section .pl-mh,div#p>svg>foreignObject>section .pl-mh .pl-en,div#p>svg>foreignObject>section .pl-ms{font-weight:700;color:#005cc5}div#p>svg>foreignObject>section .pl-mi{font-style:italic;color:#24292e}div#p>svg>foreignObject>section .pl-mb{font-weight:700;color:#24292e}div#p>svg>foreignObject>section .pl-md{color:#b31d28;background-color:#ffeef0}div#p>svg>foreignObject>section .pl-mi1{color:#22863a;background-color:#f0fff4}div#p>svg>foreignObject>section .pl-mc{color:#e36209;background-color:#ffebda}div#p>svg>foreignObject>section .pl-mi2{color:#f6f8fa;background-color:#005cc5}div#p>svg>foreignObject>section .pl-mdr{font-weight:700;color:#6f42c1}div#p>svg>foreignObject>section .pl-ba{color:#586069}div#p>svg>foreignObject>section .pl-sg{color:#959da5}div#p>svg>foreignObject>section .pl-corl{text-decoration:underline;color:#032f62}div#p>svg>foreignObject>section .mb-0{margin-bottom:0!important}div#p>svg>foreignObject>section .my-2{margin-bottom:8px!important;margin-top:8px!important}div#p>svg>foreignObject>section .pl-0{padding-left:0!important}div#p>svg>foreignObject>section .py-0{padding-top:0!important;padding-bottom:0!important}div#p>svg>foreignObject>section .pl-1{padding-left:4px!important}div#p>svg>foreignObject>section .pl-2{padding-left:8px!important}div#p>svg>foreignObject>section .py-2{padding-top:8px!important;padding-bottom:8px!important}div#p>svg>foreignObject>section .pl-3{padding-left:16px!important}div#p>svg>foreignObject>section .pl-4{padding-left:24px!important}div#p>svg>foreignObject>section .pl-5{padding-left:32px!important}div#p>svg>foreignObject>section .pl-6{padding-left:40px!important}div#p>svg>foreignObject>section .pl-7{padding-left:48px!important}div#p>svg>foreignObject>section .pl-8{padding-left:64px!important}div#p>svg>foreignObject>section .pl-9{padding-left:80px!important}div#p>svg>foreignObject>section .pl-10{padding-left:96px!important}div#p>svg>foreignObject>section .pl-11{padding-left:112px!important}div#p>svg>foreignObject>section .pl-12{padding-left:128px!important}div#p>svg>foreignObject>section hr{border-bottom-color:#eee}div#p>svg>foreignObject>section kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}div#p>svg>foreignObject>section:after,div#p>svg>foreignObject>section:before{display:table
  /* content:""; */}div#p>svg>foreignObject>section:after{clear:both}div#p>svg>foreignObject>section>:first-child{margin-top:0!important}div#p>svg>foreignObject>section>:last-child{margin-bottom:0!important}div#p>svg>foreignObject>section a:not([href]){color:inherit;text-decoration:none}div#p>svg>foreignObject>section blockquote,div#p>svg>foreignObject>section details,div#p>svg>foreignObject>section dl,div#p>svg>foreignObject>section ol,div#p>svg>foreignObject>section p,div#p>svg>foreignObject>section pre,div#p>svg>foreignObject>section table,div#p>svg>foreignObject>section ul{margin-top:0;margin-bottom:16px}div#p>svg>foreignObject>section hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}div#p>svg>foreignObject>section blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}div#p>svg>foreignObject>section blockquote>:first-child{margin-top:0}div#p>svg>foreignObject>section blockquote>:last-child{margin-bottom:0}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2,div#p>svg>foreignObject>section h3,div#p>svg>foreignObject>section h4,div#p>svg>foreignObject>section h5,div#p>svg>foreignObject>section h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}div#p>svg>foreignObject>section h1{font-size:2em}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}div#p>svg>foreignObject>section h2{font-size:1.5em}div#p>svg>foreignObject>section h3{font-size:1.25em}div#p>svg>foreignObject>section h4{font-size:1em}div#p>svg>foreignObject>section h5{font-size:.875em}div#p>svg>foreignObject>section h6{font-size:.85em;color:#6a737d}div#p>svg>foreignObject>section ol,div#p>svg>foreignObject>section ul{padding-left:2em}div#p>svg>foreignObject>section ol ol,div#p>svg>foreignObject>section ol ul,div#p>svg>foreignObject>section ul ol,div#p>svg>foreignObject>section ul ul{margin-top:0;margin-bottom:0}div#p>svg>foreignObject>section li{word-wrap:break-all}div#p>svg>foreignObject>section li>p{margin-top:16px}div#p>svg>foreignObject>section li+li{margin-top:.25em}div#p>svg>foreignObject>section dl{padding:0}div#p>svg>foreignObject>section dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}div#p>svg>foreignObject>section dl dd{padding:0 16px;margin-bottom:16px}div#p>svg>foreignObject>section table{display:block;width:100%;overflow:auto}div#p>svg>foreignObject>section table th{font-weight:600}div#p>svg>foreignObject>section table td,div#p>svg>foreignObject>section table th{padding:6px 13px;border:1px solid #dfe2e5}div#p>svg>foreignObject>section table tr{background-color:#fff;border-top:1px solid #c6cbd1}div#p>svg>foreignObject>section table tr:nth-child(2n){background-color:#f6f8fa}div#p>svg>foreignObject>section img{max-width:100%;box-sizing:initial;background-color:#fff}div#p>svg>foreignObject>section img[align=right]{padding-left:20px}div#p>svg>foreignObject>section img[align=left]{padding-right:20px}div#p>svg>foreignObject>section code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}div#p>svg>foreignObject>section pre{word-wrap:normal}div#p>svg>foreignObject>section pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}div#p>svg>foreignObject>section .highlight{margin-bottom:16px}div#p>svg>foreignObject>section .highlight pre{margin-bottom:0;word-break:normal}div#p>svg>foreignObject>section pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}div#p>svg>foreignObject>section pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}div#p>svg>foreignObject>section .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}div#p>svg>foreignObject>section .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}div#p>svg>foreignObject>section .blob-wrapper{overflow-x:auto;overflow-y:hidden}div#p>svg>foreignObject>section .blob-wrapper-embedded{max-height:240px;overflow-y:auto}div#p>svg>foreignObject>section .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}div#p>svg>foreignObject>section .blob-num:hover{color:rgba(27,31,35,.6)}div#p>svg>foreignObject>section .blob-num:before{content:attr(data-line-number)}div#p>svg>foreignObject>section .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}div#p>svg>foreignObject>section .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}div#p>svg>foreignObject>section .pl-token.active,div#p>svg>foreignObject>section .pl-token:hover{cursor:pointer;background:#ffea7f}div#p>svg>foreignObject>section .tab-size[data-tab-size="1"]{-moz-tab-size:1;-o-tab-size:1;tab-size:1}div#p>svg>foreignObject>section .tab-size[data-tab-size="2"]{-moz-tab-size:2;-o-tab-size:2;tab-size:2}div#p>svg>foreignObject>section .tab-size[data-tab-size="3"]{-moz-tab-size:3;-o-tab-size:3;tab-size:3}div#p>svg>foreignObject>section .tab-size[data-tab-size="4"]{-moz-tab-size:4;-o-tab-size:4;tab-size:4}div#p>svg>foreignObject>section .tab-size[data-tab-size="5"]{-moz-tab-size:5;-o-tab-size:5;tab-size:5}div#p>svg>foreignObject>section .tab-size[data-tab-size="6"]{-moz-tab-size:6;-o-tab-size:6;tab-size:6}div#p>svg>foreignObject>section .tab-size[data-tab-size="7"]{-moz-tab-size:7;-o-tab-size:7;tab-size:7}div#p>svg>foreignObject>section .tab-size[data-tab-size="8"]{-moz-tab-size:8;-o-tab-size:8;tab-size:8}div#p>svg>foreignObject>section .tab-size[data-tab-size="9"]{-moz-tab-size:9;-o-tab-size:9;tab-size:9}div#p>svg>foreignObject>section .tab-size[data-tab-size="10"]{-moz-tab-size:10;-o-tab-size:10;tab-size:10}div#p>svg>foreignObject>section .tab-size[data-tab-size="11"]{-moz-tab-size:11;-o-tab-size:11;tab-size:11}div#p>svg>foreignObject>section .tab-size[data-tab-size="12"]{-moz-tab-size:12;-o-tab-size:12;tab-size:12}div#p>svg>foreignObject>section .task-list-item{list-style-type:none}div#p>svg>foreignObject>section .task-list-item+.task-list-item{margin-top:3px}div#p>svg>foreignObject>section .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}div#p>svg>foreignObject>section .hljs{display:block;background:#fff;padding:.5em;color:#333;overflow-x:auto}div#p>svg>foreignObject>section .hljs-comment,div#p>svg>foreignObject>section .hljs-meta{color:#969896}div#p>svg>foreignObject>section .hljs-emphasis,div#p>svg>foreignObject>section .hljs-quote,div#p>svg>foreignObject>section .hljs-strong,div#p>svg>foreignObject>section .hljs-template-variable,div#p>svg>foreignObject>section .hljs-variable{color:#df5000}div#p>svg>foreignObject>section .hljs-keyword,div#p>svg>foreignObject>section .hljs-selector-tag,div#p>svg>foreignObject>section .hljs-type{color:#d73a49}div#p>svg>foreignObject>section .hljs-attribute,div#p>svg>foreignObject>section .hljs-bullet,div#p>svg>foreignObject>section .hljs-literal,div#p>svg>foreignObject>section .hljs-symbol{color:#0086b3}div#p>svg>foreignObject>section .hljs-name,div#p>svg>foreignObject>section .hljs-section{color:#63a35c}div#p>svg>foreignObject>section .hljs-tag{color:#333}div#p>svg>foreignObject>section .hljs-attr,div#p>svg>foreignObject>section .hljs-selector-attr,div#p>svg>foreignObject>section .hljs-selector-class,div#p>svg>foreignObject>section .hljs-selector-id,div#p>svg>foreignObject>section .hljs-selector-pseudo,div#p>svg>foreignObject>section .hljs-title{color:#6f42c1}div#p>svg>foreignObject>section .hljs-addition{color:#55a532;background-color:#eaffea}div#p>svg>foreignObject>section .hljs-deletion{color:#bd2c00;background-color:#ffecec}div#p>svg>foreignObject>section .hljs-link{text-decoration:underline}div#p>svg>foreignObject>section .hljs-number{color:#005cc5}div#p>svg>foreignObject>section .hljs-string{color:#032f62}div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{max-height:563px}div#p>svg>foreignObject>section h1{color:#246;font-size:1.6em}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2{border-bottom:none}div#p>svg>foreignObject>section h2{font-size:1.3em}div#p>svg>foreignObject>section h3{font-size:1.1em}div#p>svg>foreignObject>section h4{font-size:1.05em}div#p>svg>foreignObject>section h5{font-size:1em}div#p>svg>foreignObject>section h6{font-size:.9em}div#p>svg>foreignObject>section h1 strong,div#p>svg>foreignObject>section h2 strong,div#p>svg>foreignObject>section h3 strong,div#p>svg>foreignObject>section h4 strong,div#p>svg>foreignObject>section h5 strong,div#p>svg>foreignObject>section h6 strong{font-weight:inherit;color:#48c}div#p>svg>foreignObject>section hr{height:0;padding-top:.25em}div#p>svg>foreignObject>section pre{border:1px solid #999;line-height:1.15;overflow:visible}div#p>svg>foreignObject>section pre code svg[data-marp-fitting=svg]{max-height:529px}div#p>svg>foreignObject>section footer,div#p>svg>foreignObject>section header{margin:0;position:absolute;left:30px;color:hsla(0,0%,40%,.75);font-size:18px}div#p>svg>foreignObject>section header{top:21px}div#p>svg>foreignObject>section footer{bottom:21px}div#p>svg>foreignObject>section{align-items:stretch;background:#fff;display:flex;flex-direction:column;flex-wrap:nowrap;font-size:29px;height:720px;justify-content:center;padding:78.5px;width:1280px}div#p>svg>foreignObject>section>:last-child,div#p>svg>foreignObject>section[data-footer]>:nth-last-child(2){margin-bottom:0}div#p>svg>foreignObject>section>:first-child,div#p>svg>foreignObject>section>header:first-child+*{margin-top:0}div#p>svg>foreignObject>section:after{position:absolute;padding:0;right:30px;bottom:21px;font-size:24px;color:#777}div#p>svg>foreignObject>section.invert{background-color:#222;color:#e6eaf0}div#p>svg>foreignObject>section.invert:after{color:#999}div#p>svg>foreignObject>section.invert img{background-color:transparent}div#p>svg>foreignObject>section.invert a{color:#50b3ff}div#p>svg>foreignObject>section.invert h1{color:#a3c5e7}div#p>svg>foreignObject>section.invert h2,div#p>svg>foreignObject>section.invert h3,div#p>svg>foreignObject>section.invert h4,div#p>svg>foreignObject>section.invert h5{color:#ebeff5}div#p>svg>foreignObject>section.invert blockquote,div#p>svg>foreignObject>section.invert h6{border-color:#3d3f43;color:#939699}div#p>svg>foreignObject>section.invert h1 strong,div#p>svg>foreignObject>section.invert h2 strong,div#p>svg>foreignObject>section.invert h3 strong,div#p>svg>foreignObject>section.invert h4 strong,div#p>svg>foreignObject>section.invert h5 strong,div#p>svg>foreignObject>section.invert h6 strong{color:#7bf}div#p>svg>foreignObject>section.invert hr{background-color:#3d3f43}div#p>svg>foreignObject>section.invert footer,div#p>svg>foreignObject>section.invert header{color:hsla(0,0%,60%,.75)}div#p>svg>foreignObject>section.invert code,div#p>svg>foreignObject>section.invert kbd{background-color:#111}div#p>svg>foreignObject>section.invert kbd{border-color:#666;box-shadow:inset 0 -1px 0 #555;color:#e6eaf0}div#p>svg>foreignObject>section.invert table tr{background-color:#12181d;border-color:#60657b}div#p>svg>foreignObject>section.invert table tr:nth-child(2n){background-color:#1b2024}div#p>svg>foreignObject>section.invert table td,div#p>svg>foreignObject>section.invert table th{border-color:#5b5e61}div#p>svg>foreignObject>section.invert pre{background-color:#0a0e12;border-color:#777}div#p>svg>foreignObject>section.invert pre code{background-color:transparent}div#p>svg>foreignObject>section[data-color] h1,div#p>svg>foreignObject>section[data-color] h2,div#p>svg>foreignObject>section[data-color] h3,div#p>svg>foreignObject>section[data-color] h4,div#p>svg>foreignObject>section[data-color] h5,div#p>svg>foreignObject>section[data-color] h6{color:currentColor}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]{display:block!important;padding:0!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]:after,div#p>svg>foreignObject>section[data-marpit-advanced-background=background]:before,div#p>svg>foreignObject>section[data-marpit-advanced-background=content]:after,div#p>svg>foreignObject>section[data-marpit-advanced-background=content]:before{display:none!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container]{all:initial;display:flex;flex-direction:row;height:100%;overflow:hidden;width:100%}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container][data-marpit-advanced-background-direction=vertical]{flex-direction:column}div#p>svg>foreignObject>section[data-marpit-advanced-background=background][data-marpit-advanced-background-split]>div[data-marpit-advanced-background-container]{width:var(--marpit-advanced-background-split,50%)}div#p>svg>foreignObject>section[data-marpit-advanced-background=background][data-marpit-advanced-background-split=right]>div[data-marpit-advanced-background-container]{margin-left:calc(100% - var(--marpit-advanced-background-split, 50%))}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container]>figure{all:initial;background-position:center;background-repeat:no-repeat;background-size:cover;flex:auto;margin:0}div#p>svg>foreignObject>section[data-marpit-advanced-background=content],div#p>svg>foreignObject>section[data-marpit-advanced-background=pseudo]{background:transparent!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=pseudo],div#p>svg[data-marpit-svg]>foreignObject[data-marpit-advanced-background=pseudo]{pointer-events:none!important}div#p>svg>foreignObject>section[data-marpit-advanced-background-split]{width:100%;height:100%}</style></head><body><div class="bespoke-marp-osc"><button data-bespoke-marp-osc="prev" tabindex="-1" title="Previous slide">Previous slide</button><span data-bespoke-marp-osc="page"></span><button data-bespoke-marp-osc="next" tabindex="-1" title="Next slide">Next slide</button><button data-bespoke-marp-osc="fullscreen" tabindex="-1" title="Toggle fullscreen (f)">Toggle fullscreen</button><button data-bespoke-marp-osc="presenter" tabindex="-1" title="Open presenter view (p)">Open presenter view</button></div><div id="p"><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="1" data-paginate="true" data-theme="default" data-marpit-pagination="1" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h1>高效的 Go 编程 Effective Go</h1>
<blockquote>
<p>本文所有内容均来自社区，这里仅做格式化整理。</p>
<p>感谢<img class="emoji" draggable="false" alt="🙏" src="https://twemoji.maxcdn.com/2/svg/1f64f.svg" data-marp-twemoji=""/>各位网友的劳动成果。</p>
<p>本文章首发在 <a href="https://learnku.com/">LearnKu.com</a> 网站上。</p>
<p>原文链接：<a href="https://learnku.com/docs/effective-go/2020">《高效的 Go 编程 Effective Go》 | Go 技术论坛</a></p>
<p>作者们的话：</p>
<p>本译文仅用于学习和交流目的，转载请务必注明文章译者、出处、和本文链接<br />
我们的翻译工作遵照 <a href="https://learnku.com/docs/guide/cc4.0/6589">CC 协议</a>，如果我们的工作有侵犯到您的权益，请及时联系我们。</p>
</blockquote>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="2" data-paginate="true" data-theme="default" data-marpit-pagination="2" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>引言</h2>
<h3>介绍</h3>
<p>Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用 Go 编程在本质上就不同于其它语言。将现有的 C++ 或 Java 程序直译为 Go 程序并不能令人满意 —— 毕竟 Java 程序是用 Java 编写的，而不是 Go。 另一方面，若从 Go 的角度去分析问题，你就能编写出同样可行但大不相同的程序。 换句话说，要想将 Go 程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="3" data-paginate="true" data-theme="default" data-marpit-pagination="3" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>本文档就如何编写清晰、地道的 Go 代码提供了一些技巧。它是对<a href="https://go-zh.org/ref/spec">语言规范</a>、 <a href="https://learnku.com/golang/wikis/38166">Go 语言之旅</a>以及 <a href="https://learnku.com/golang/wikis/38174">如何使用 Go 编程</a> 的补充说明，因此我们建议您先阅读这些文档。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="4" data-paginate="true" data-theme="default" data-marpit-pagination="4" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>示例</h3>
<p><a href="https://golang.org/src/">Go 包的源码</a> 不仅是核心库，同时也是学习如何使用 Go 语言的示例源码。 此外，其中的一些包还包含了可独立的可执行示例，你可以直接在 <a href="http://golang.org/">golang.org</a> 网站上运行它们，比如 <a href="https://golang.org/pkg/strings/#example_Map">这个例子</a> 。如果你有任何关于某些问题如何解决，或某些东西如何实现的疑问， 也可以从中获取相关的答案、思路以及后台实现。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="5" data-paginate="true" data-theme="default" data-marpit-pagination="5" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>格式化</h2>
<p>格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="6" data-paginate="true" data-theme="default" data-marpit-pagination="6" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>在 Go 中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>gofmt</code> 程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将 Go 程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行 <code>gofmt</code>；若结果仍不尽人意，请重新组织你的程序（或提交有关 <code>gofmt</code> 的 Bug），而不必为此纠结。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="7" data-paginate="true" data-theme="default" data-marpit-pagination="7" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>举例来说，你无需花时间将结构体中的字段注释对齐，<code>gofmt</code> 将为你代劳。 假如有以下声明：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> {
    name <span class="hljs-keyword">string</span> <span class="hljs-comment">// 对象名</span>
    value <span class="hljs-keyword">int</span> <span class="hljs-comment">// 对象值</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="8" data-paginate="true" data-theme="default" data-marpit-pagination="8" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>gofmt</code> 会将它按列对齐为：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> {
    name    <span class="hljs-keyword">string</span> <span class="hljs-comment">// name of the object</span>
    value   <span class="hljs-keyword">int</span>    <span class="hljs-comment">// its value</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="9" data-paginate="true" data-theme="default" data-marpit-pagination="9" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>标准包中所有的 Go 代码都已经用 <code>gofmt</code> 格式化过了。</p>
<p>还有一些关于格式化的细节，它们非常简短：</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="10" data-paginate="true" data-theme="default" data-marpit-pagination="10" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><strong>缩进</strong></p>
<p>我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="11" data-paginate="true" data-theme="default" data-marpit-pagination="11" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><strong>行的长度</strong></p>
<p>Go 对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的 tab 缩进。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="12" data-paginate="true" data-theme="default" data-marpit-pagination="12" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><strong>括号</strong></p>
<p>比起 C 和 Java，Go 所需的括号更少：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁，因此</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>x&lt;&lt;<span class="hljs-number">8</span> + y&lt;&lt;<span class="hljs-number">16</span>
</span></span></foreignObject></svg></code></pre>
<p>正表述了空格符所传达的含义。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="13" data-paginate="true" data-theme="default" data-marpit-pagination="13" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>代码注释</h2>
<p>Go 语言支持 C 风格的块注释 <code>/* */</code> 和 C++ 风格的行注释 <code>//</code>。 行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="14" data-paginate="true" data-theme="default" data-marpit-pagination="14" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>godoc</code> 既是一个程序，又是一个 Web 服务器，它对 Go 的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。 这些注释的类型和风格决定了 <code>godoc</code> 生成的文档质量。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="15" data-paginate="true" data-theme="default" data-marpit-pagination="15" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>每个包都应包含一段<strong>包注释</strong>，即放置在包子句前的一个块注释。对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 <code>godoc</code> 页面中的最上面，并为紧随其后的内容建立详细的文档。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="16" data-paginate="true" data-theme="default" data-marpit-pagination="16" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">/*
regexp 包为正则表达式实现了一个简单的库。

该库接受的正则表达式语法为：

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/</span>
<span class="hljs-keyword">package</span> regexp
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="17" data-paginate="true" data-theme="default" data-marpit-pagination="17" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若某个包比较简单，包注释同样可以简洁些。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// path 包实现了一些常用的工具，</span>
<span class="hljs-comment">// 以便于操作用反斜杠分隔的路径.</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="18" data-paginate="true" data-theme="default" data-marpit-pagination="18" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。 注释是不会被解析的纯文本，因此像 HTML 或其它类似于 <code>_这样_</code> 的东西将按照 <strong>原样</strong> 输出，因此不应使用它们。<code>godoc</code> 所做的调整， 就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。 <a href="http://golang.org/pkg/fmt/"><code>fmt</code> 包</a>的注释就用了这种不错的效果。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="19" data-paginate="true" data-theme="default" data-marpit-pagination="19" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>godoc</code> 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨： 使用正确的拼写、标点和语句结构以及折叠长行等。</p>
<p>在包中，任何顶级声明前面的注释都将作为该声明的<strong>文档注释</strong>。 在程序中，每个可导出（首字母大写）的名称都应该有文档注释。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="20" data-paginate="true" data-theme="default" data-marpit-pagination="20" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// Compile 用于解析正则表达式并返回，如果成</span>
<span class="hljs-comment">// 功，则 Regexp 对象就可用于匹配所针对的文本。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compile</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*Regexp, error)</span></span> {
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="21" data-paginate="true" data-theme="default" data-marpit-pagination="21" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若注释总是以名称开头，<code>go doc</code> 命令的输出就能通过 <code>grep</code> 变得更加有用。假如你记不住 <code>Compile</code> 这个名称，而又在找正则表达式的解析函数（『解析』意味着关键词为 <code>parse</code>）， 那就可以运行</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>$ <span class="hljs-keyword">go</span> doc -all regexp | grep -i parse
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="22" data-paginate="true" data-theme="default" data-marpit-pagination="22" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若包中的所有文档注释都以 <code>This function...</code> 开头，<code>grep</code> 就无法帮你记住此名称。 但由于每个包的文档注释都以其名称开头，你就能看到这样的内容，它能显示你正在寻找的词语。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>$ <span class="hljs-keyword">go</span> doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, <span class="hljs-keyword">if</span> successful, a Regexp
    MustCompile is like Compile but panics <span class="hljs-keyword">if</span> the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="23" data-paginate="true" data-theme="default" data-marpit-pagination="23" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>Go 的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 表达式解析失败后返回错误代码</span>
<span class="hljs-keyword">var</span> (
    ErrInternal      = errors.New(<span class="hljs-string">"regexp: internal error"</span>)
    ErrUnmatchedLpar = errors.New(<span class="hljs-string">"regexp: unmatched '('"</span>)
    ErrUnmatchedRpar = errors.New(<span class="hljs-string">"regexp: unmatched ')'"</span>)
    ...
)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="24" data-paginate="true" data-theme="default" data-marpit-pagination="24" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> (
    countLock   sync.Mutex
    inputCount  <span class="hljs-keyword">uint32</span>
    outputCount <span class="hljs-keyword">uint32</span>
    errorCount  <span class="hljs-keyword">uint32</span>
)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="25" data-paginate="true" data-theme="default" data-marpit-pagination="25" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>命名规则</h2>
<p>正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义： 例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母。 因此有必要花点时间来讨论 Go 程序中的命名约定。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="26" data-paginate="true" data-theme="default" data-marpit-pagination="26" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>包名</h3>
<p>当一个包被导入后，包名就会成了内容的访问器。在以下代码</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">import</span> <span class="hljs-string">"bytes"</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="27" data-paginate="true" data-theme="default" data-marpit-pagination="27" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了。 若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例， 包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法。<code>err</code> 的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。 不必担心<strong>引用次序</strong>的冲突。包名就是导入时所需的唯一默认名称， 它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下， 也可为导入的包选择一个别名来局部使用。 无论如何，通过文件名来判定使用的包，都是不会产生混淆的。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="28" data-paginate="true" data-theme="default" data-marpit-pagination="28" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code> 中的包应作为 <code>&quot;encoding/base64&quot;</code> 导入，其包名应为 <code>base64</code>， 而非 <code>encoding_base64</code> 或 <code>encodingBase64</code>。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="29" data-paginate="true" data-theme="default" data-marpit-pagination="29" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。 （请勿使用 <code>import .</code> 记法，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用。）例如，<code>bufio</code> 包中的缓存读取器类型叫做 <code>Reader</code> 而非 <code>BufReader</code>，因为用户将它看做 <code>bufio.Reader</code>，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此 <code>bufio.Reader</code> 不会与 <code>io.Reader</code> 发生冲突。同样，用于创建 <code>ring.Ring</code> 的新实例的函数（这就是 Go 中的<strong>构造函数</strong>）一般会称之为 <code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫 <code>ring</code>，因此它可以只叫做 <code>New</code>，它跟在包的后面，就像 <code>ring.New</code>。使用包结构可以帮助你选择好的名称。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="30" data-paginate="true" data-theme="default" data-marpit-pagination="30" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code> 表述足够清晰， 使用 <code>once.DoOrWaitUntilDone(setup)</code> 完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="31" data-paginate="true" data-theme="default" data-marpit-pagination="31" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>获取器</h3>
<p>Go 并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code> 放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>owner := obj.Owner()
<span class="hljs-keyword">if</span> owner != user {
    obj.SetOwner(user)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="32" data-paginate="true" data-theme="default" data-marpit-pagination="32" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>接口命名</h3>
<p>按照约定，只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code> 等。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="33" data-paginate="true" data-theme="default" data-marpit-pagination="33" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。 <code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、 <code>String</code> 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 请将字符串转换方法命名为 <code>String</code> 而非 <code>ToString</code>。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="34" data-paginate="true" data-theme="default" data-marpit-pagination="34" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>驼峰 命名</h3>
<p>最后，Go 中的约定是使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 而不是下划线来编写多个单词组成的命名。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="35" data-paginate="true" data-theme="default" data-marpit-pagination="35" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>分号</h2>
<p>和 C 一样，Go 的正式语法使用分号来结束语句；和 C 不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="36" data-paginate="true" data-theme="default" data-marpit-pagination="36" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和 <code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">break</span> <span class="hljs-keyword">continue</span> <span class="hljs-keyword">fallthrough</span> <span class="hljs-keyword">return</span> ++ -- ) }
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="37" data-paginate="true" data-theme="default" data-marpit-pagination="37" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>则词法分析将始终在该标记后面插入分号。这点可以概括为： “如果新行前的标记为语句的末尾，则插入分号”。</p>
<p>分号也可在闭括号之前直接省略，因此像</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { <span class="hljs-keyword">for</span> { dst &lt;- &lt;-src } }()
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="38" data-paginate="true" data-theme="default" data-marpit-pagination="38" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这样的语句无需分号。通常 Go 程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="39" data-paginate="true" data-theme="default" data-marpit-pagination="39" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> i &lt; f() {
    g()
}
</span></span></foreignObject></svg></code></pre>
<p>而不是这样写</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> i &lt; f()  <span class="hljs-comment">// 错误！</span>
{           <span class="hljs-comment">//  错误！</span>
    g()
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="40" data-paginate="true" data-theme="default" data-marpit-pagination="40" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>控制结构</h2>
<p>Go 中的结构控制与 C 有许多相似之处，但其不同之处才是独到之处。 Go 不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code> 一样可接受可选的初始化语句； 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="41" data-paginate="true" data-theme="default" data-marpit-pagination="41" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>If</h3>
<p>在 Go 中，一个简单的 <code>if</code> 语句看起来像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {
    <span class="hljs-keyword">return</span> y
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="42" data-paginate="true" data-theme="default" data-marpit-pagination="42" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>强制的大括号促使你将简单的 <code>if</code> 语句分成多行。特别是在主体中包含 <code>return</code> 或 <code>break</code> 等控制语句时，这种编码风格的好处一比便知。</p>
<p>由于 <code>if</code> 和 <code>switch</code> 可接受初始化语句， 因此用它们来设置局部变量十分常见。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> err := file.Chmod(<span class="hljs-number">0664</span>); err != <span class="hljs-literal">nil</span> {
    log.Print(err)
    <span class="hljs-keyword">return</span> err
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="43" data-paginate="true" data-theme="default" data-marpit-pagination="43" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>在 Go 的库中，你会发现若 <code>if</code> 语句不会执行到下一条语句时，亦即其执行体 以 <code>break</code>、<code>continue</code>、<code>goto</code> 或 <code>return</code> 结束时，不必要的 <code>else</code> 会被省略。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>f, err := os.Open(name)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
codeUsing(f)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="44" data-paginate="true" data-theme="default" data-marpit-pagination="44" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续， 则说明程序已排除错误。由于出错时将以 <code>return</code> 结束， 之后的代码也就无需 <code>else</code> 了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>f, err := os.Open(name)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
d, err := f.Stat()
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    f.Close()
    <span class="hljs-keyword">return</span> err
}
codeUsing(f, d)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="45" data-paginate="true" data-theme="default" data-marpit-pagination="45" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>声明和分配</h3>
<p>题外话：上一节中最后一个示例展示了短声明 := 如何使用。 调用了 os.Open 的声明为</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>f, err := os.Open(name)
</span></span></foreignObject></svg></code></pre>
<p>该语句声明了两个变量 f 和 err。在几行之后，又通过：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>d, err := f.Stat()
</span></span></foreignObject></svg></code></pre>
<p>调用了 <code>f.Stat</code>。它看起来似乎是声明了 <code>d</code> 和 <code>err</code>。 注意，尽管两个语句中都出现了 <code>err</code>，但这种重复仍然是合法的：<code>err</code> 在第一条语句中被声明，但在第二条语句中只是被<strong>再次赋值</strong>罢了。也就是说，调用 <code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="46" data-paginate="true" data-theme="default" data-marpit-pagination="46" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：</p>
<ul>
<li>本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量 §），</li>
<li>在初始化中与其类型相应的值才能赋予 <code>v</code>，且</li>
<li>在此次声明中至少另有一个变量是新声明的。</li>
</ul>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="47" data-paginate="true" data-theme="default" data-marpit-pagination="47" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这个特性简直就是纯粹的实用主义体现，它使得我们可以很方便地只使用一个 <code>err</code> 值，例如，在一个相当长的 <code>if-else</code> 语句链中， 你会发现它用得很频繁。</p>
<p>§ 值得一提的是，即便 Go 中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="48" data-paginate="true" data-theme="default" data-marpit-pagination="48" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>For</h3>
<p>Go 的 <code>for</code> 循环类似于 C，但却不尽相同。它统一了 <code>for</code> 和 <code>while</code>，不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 类似 C 语言中的 for 用法</span>
<span class="hljs-keyword">for</span> init; condition; post { }

<span class="hljs-comment">// 类似 C 语言中的 while 用法</span>
<span class="hljs-keyword">for</span> condition { }

<span class="hljs-comment">// 类似 C 语言中的 for(;;) 用法</span>
<span class="hljs-keyword">for</span> { }
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="49" data-paginate="true" data-theme="default" data-marpit-pagination="49" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>简短声明能让我们更容易在循环中声明下标变量：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>sum := <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {
    sum += i
}
</span></span></foreignObject></svg></code></pre>
<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap {
    newMap[key] = value
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="50" data-paginate="true" data-theme="default" data-marpit-pagination="50" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m {
    <span class="hljs-keyword">if</span> key.expired() {
        <span class="hljs-built_in">delete</span>(m, key)
    }
}
</span></span></foreignObject></svg></code></pre>
<p>若你只需要该遍历中的第二个项（值），请使用<strong>空白标识符</strong>，即下划线来丢弃第一个值：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>sum := <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> array {
    sum += value
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="51" data-paginate="true" data-theme="default" data-marpit-pagination="51" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>空白标识符还有多种用法，它会在后面的小节中描述。</p>
<p>对于字符串，<code>range</code> 能够提供更多便利。它能通过解析 UTF-8， 将每个独立的 Unicode 码点分离出来。错误的编码将占用一个字节，并以符文 <code>U+FFFD</code> 来代替。 （名称 “符文” 和内建类型 <code>rune</code> 是 Go 对单个 Unicode 码点的成称谓。 详情见<a href="https://golang.org/ref/spec#Rune_literals">语言规范</a>）。循环</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">for</span> pos, char := <span class="hljs-keyword">range</span> <span class="hljs-string">"日本\x80語"</span> { <span class="hljs-comment">// \x80 在 UTF-8 编码中是一个非法字符</span>
    fmt.Printf(<span class="hljs-string">"character %#U starts at byte position %d\n"</span>, char, pos)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="52" data-paginate="true" data-theme="default" data-marpit-pagination="52" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>打印结果：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>character U+<span class="hljs-number">65E5</span> <span class="hljs-string">'日'</span> starts at <span class="hljs-keyword">byte</span> position <span class="hljs-number">0</span>
character U+<span class="hljs-number">672</span>C <span class="hljs-string">'本'</span> starts at <span class="hljs-keyword">byte</span> position <span class="hljs-number">3</span>
character U+FFFD <span class="hljs-string">'�'</span> starts at <span class="hljs-keyword">byte</span> position <span class="hljs-number">6</span>
character U+<span class="hljs-number">8</span>A9E <span class="hljs-string">'語'</span> starts at <span class="hljs-keyword">byte</span> position <span class="hljs-number">7</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="53" data-paginate="true" data-theme="default" data-marpit-pagination="53" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>最后，Go 没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code>）.</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// Reverse a</span>
<span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> {
    a[i], a[j] = a[j], a[i]
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="54" data-paginate="true" data-theme="default" data-marpit-pagination="54" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>Switch</h3>
<p>Go 的 <code>switch</code> 比 C 的更通用。其表达式无需为常量或整数，<code>case</code> 语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个 <code>switch</code>，这也更符合 Go 的风格。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unhex</span><span class="hljs-params">(c <span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">byte</span></span> {
    <span class="hljs-keyword">switch</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>:
        <span class="hljs-keyword">return</span> c - <span class="hljs-string">'0'</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">'f'</span>:
        <span class="hljs-keyword">return</span> c - <span class="hljs-string">'a'</span> + <span class="hljs-number">10</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">'F'</span>:
        <span class="hljs-keyword">return</span> c - <span class="hljs-string">'A'</span> + <span class="hljs-number">10</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="55" data-paginate="true" data-theme="default" data-marpit-pagination="55" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldEscape</span><span class="hljs-params">(c <span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">switch</span> c {
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>, <span class="hljs-string">'?'</span>, <span class="hljs-string">'&amp;'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'#'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'%'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="56" data-paginate="true" data-theme="default" data-marpit-pagination="56" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>尽管它们在 Go 中的用法和其它类 C 语言差不多，但 <code>break</code> 语句可以使 <code>switch</code> 提前终止。不仅是 <code>switch</code>， 有时候也必须打破层层的循环。在 Go 中，我们只需将标签放置到循环外，然后 “蹦” 到那里即可。下面的例子展示了二者的用法。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>Loop:
    <span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; <span class="hljs-built_in">len</span>(src); n += size {
        <span class="hljs-keyword">switch</span> {
        <span class="hljs-keyword">case</span> src[n] &lt; sizeOne:
            <span class="hljs-keyword">if</span> validateOnly {
                <span class="hljs-keyword">break</span>
            }
            size = <span class="hljs-number">1</span>
            update(src[n])

        <span class="hljs-keyword">case</span> src[n] &lt; sizeTwo:
            <span class="hljs-keyword">if</span> n+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(src) {
                err = errShortInput
                <span class="hljs-keyword">break</span> Loop
            }
            <span class="hljs-keyword">if</span> validateOnly {
                <span class="hljs-keyword">break</span>
            }
            size = <span class="hljs-number">2</span>
            update(src[n] + src[n+<span class="hljs-number">1</span>]&lt;&lt;shift)
        }
    }
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="57" data-paginate="true" data-theme="default" data-marpit-pagination="57" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>当然，<code>continue</code> 语句也能接受一个可选的标签，不过它只能在循环中使用。</p>
<p>作为这一节的结束，此程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 比较两个字节型切片，返回一个整数</span>
<span class="hljs-comment">// 按字典顺序.</span>
<span class="hljs-comment">// 如果a == b，结果为0；如果a &lt; b，结果为-1；如果a &gt; b，结果为+1</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span><span class="hljs-params">(a, b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a) &amp;&amp; i &lt; <span class="hljs-built_in">len</span>(b); i++ {
        <span class="hljs-keyword">switch</span> {
        <span class="hljs-keyword">case</span> a[i] &gt; b[i]:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">case</span> a[i] &lt; b[i]:
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
        }
    }
    <span class="hljs-keyword">switch</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &gt; <span class="hljs-built_in">len</span>(b):
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &lt; <span class="hljs-built_in">len</span>(b):
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="58" data-paginate="true" data-theme="default" data-marpit-pagination="58" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>类型选择</h3>
<p><code>switch</code> 也可用于判断接口变量的动态类型。如 <strong>类型选择</strong> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> t <span class="hljs-keyword">interface</span>{}
t = functionOfSomeType()
<span class="hljs-keyword">switch</span> t := t.(<span class="hljs-keyword">type</span>) {
<span class="hljs-keyword">default</span>:
    fmt.Printf(<span class="hljs-string">"unexpected type %T\n"</span>, t)     <span class="hljs-comment">// %T 打印任何类型的 t</span>
<span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:
    fmt.Printf(<span class="hljs-string">"boolean %t\n"</span>, t)             <span class="hljs-comment">// t 是 bool 类型</span>
<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:
    fmt.Printf(<span class="hljs-string">"integer %d\n"</span>, t)             <span class="hljs-comment">// t 是 int 类型</span>
<span class="hljs-keyword">case</span> *<span class="hljs-keyword">bool</span>:
    fmt.Printf(<span class="hljs-string">"pointer to boolean %t\n"</span>, *t) <span class="hljs-comment">// t 是 *bool 类型</span>
<span class="hljs-keyword">case</span> *<span class="hljs-keyword">int</span>:
    fmt.Printf(<span class="hljs-string">"pointer to integer %d\n"</span>, *t) <span class="hljs-comment">// t 是 *int 类型</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="59" data-paginate="true" data-theme="default" data-marpit-pagination="59" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>函数</h2>
<h3>多返回值</h3>
<p>Go 与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善 C 中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。</p>
<p>在 C 中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。 而在 Go 中，<code>Write</code> 会返回写入的字节数<strong>以及</strong>一个错误： “是的，您写入了一些字节，但并未全部写入，因为设备已满”。 在 <code>os</code> 包中，<code>File.Write</code> 的签名为：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(file *File)</span> <span class="hljs-title">Write</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span>
</span></span></foreignObject></svg></code></pre>
<p>正如文档所述，它返回写入的字节数，并在 <code>n != len(b)</code> 时返回一个非 <code>nil</code> 的 <code>error</code> 错误值。 这是一种常见的编码风格，更多示例见错误处理一节。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="60" data-paginate="true" data-theme="default" data-marpit-pagination="60" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>我们可以采用一种简单的方法。来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextInt</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> {
    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*<span class="hljs-number">10</span> + <span class="hljs-keyword">int</span>(b[i]) - <span class="hljs-string">'0'</span>
    }
    <span class="hljs-keyword">return</span> x, i
}
</span></span></foreignObject></svg></code></pre>
<p>你可以像下面这样，通过它扫描输入的切片 <code>b</code> 来获取数字。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="61" data-paginate="true" data-theme="default" data-marpit-pagination="61" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>命名结果参数</h3>
<p>Go 函数的返回值或结果 “形参” 可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。</p>
<p>此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 <code>nextInt</code> 的结果，那么它返回的 <code>int</code> 就值如其意了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextInt</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>, pos <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(value, nextPos <span class="hljs-keyword">int</span>)</span></span> {
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="62" data-paginate="true" data-theme="default" data-marpit-pagination="62" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 <code>io.ReadFull</code> 就是个很好的例子：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFull</span><span class="hljs-params">(r Reader, buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> {
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(buf) &gt; <span class="hljs-number">0</span> &amp;&amp; err == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">var</span> nr <span class="hljs-keyword">int</span>
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    <span class="hljs-keyword">return</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="63" data-paginate="true" data-theme="default" data-marpit-pagination="63" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>延迟 <code>defer</code></h3>
<p>Go 的 <code>defer</code> 语句用于预设一个函数调用（即<strong>推迟执行</strong>函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 内容返回文件的内容作为字符串。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contents</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> {
    f, err := os.Open(filename)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err
    }
    <span class="hljs-keyword">defer</span> f.Close()  <span class="hljs-comment">// 我们结束后就关闭了f</span>

    <span class="hljs-keyword">var</span> result []<span class="hljs-keyword">byte</span>
    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">100</span>)
    <span class="hljs-keyword">for</span> {
        n, err := f.Read(buf[<span class="hljs-number">0</span>:])
        result = <span class="hljs-built_in">append</span>(result, buf[<span class="hljs-number">0</span>:n]...) <span class="hljs-comment">// append稍后讨论。</span>
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">if</span> err == io.EOF {
                <span class="hljs-keyword">break</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err  <span class="hljs-comment">// 如果我们回到这里，f就关闭了。</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(result), <span class="hljs-literal">nil</span> <span class="hljs-comment">// 如果我们回到这里，f就关闭了。</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="64" data-paginate="true" data-theme="default" data-marpit-pagination="64" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>推迟诸如 <code>Close</code> 之类的函数调用有两点好处：第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生。第二，它意味着 “关闭” 离 “打开” 很近， 这总比将它放在函数结尾处要清晰明了。</p>
<p>被推迟函数的实参（如果该函数为方法则还包括接收者）在<strong>推迟</strong>执行时就会求值， 而不是在<strong>调用</strong>执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ {
    <span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">"%d "</span>, i)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="65" data-paginate="true" data-theme="default" data-marpit-pagination="65" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 <code>4 3 2 1 0</code>。一个更具实际意义的例子是通过一种简单的方法， 用程序来跟踪函数的执行。我们可以编写一对简单的跟踪例程：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span>   { fmt.Println(<span class="hljs-string">"entering:"</span>, s) }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> { fmt.Println(<span class="hljs-string">"leaving:"</span>, s) }

<span class="hljs-comment">// Use them like this:</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> {
    trace(<span class="hljs-string">"a"</span>)
    <span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">"a"</span>)
    <span class="hljs-comment">// do something....</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="66" data-paginate="true" data-theme="default" data-marpit-pagination="66" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>我们可以充分利用这个特点，即被推迟函数的实参在 <code>defer</code> 执行时才会被求值。 跟踪例程可针对反跟踪例程设置实参。以下例子：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {
    fmt.Println(<span class="hljs-string">"entering:"</span>, s)
    <span class="hljs-keyword">return</span> s
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">un</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> {
    fmt.Println(<span class="hljs-string">"leaving:"</span>, s)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">"a"</span>))
    fmt.Println(<span class="hljs-string">"in a"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">"b"</span>))
    fmt.Println(<span class="hljs-string">"in b"</span>)
    a()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    b()
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="67" data-paginate="true" data-theme="default" data-marpit-pagination="67" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>会打印</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>entering: b
in b
entering: a
in a
leaving: a
leaving: b
</span></span></foreignObject></svg></code></pre>
<p>对于习惯其它语言中块级资源管理的程序员，<code>defer</code> 似乎有点怪异， 但它最有趣而强大的应用恰恰来自于其基于函数而非块的特点。在 <code>panic</code> 和 <code>recover</code> 这两节中，我们将看到关于它可能性的其它例子。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="68" data-paginate="true" data-theme="default" data-marpit-pagination="68" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>数据</h2>
<h3>使用 new 关键字分配内存</h3>
<p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code>。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 让我们先来看看 <code>new</code>。这是个用来分配内存的内建函数， 但与其它语言中的同名函数不同，它不会<strong>初始化</strong>内存，只会将内存<strong>置零</strong>。 也就是说，<code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间， 并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用 Go 的术语来说，它返回一个指针， 该指针指向新分配的，类型为 <code>T</code> 的零值。</p>
<p>既然 <code>new</code> 返回的内存已置零，那么当你设计数据结构时， 每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需用 <code>new</code> 创建一个新的对象就能正常工作。例如，<code>bytes.Buffer</code> 的文档中提到 “零值的 <code>Buffer</code> 就是已准备就绪的缓冲区。” 同样，<code>sync.Mutex</code> 并没有显式的构造函数或 <code>Init</code> 方法， 而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁了。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="69" data-paginate="true" data-theme="default" data-marpit-pagination="69" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>“零值属性” 可以带来各种好处。考虑以下类型声明。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> SyncedBuffer <span class="hljs-keyword">struct</span> {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</span></span></foreignObject></svg></code></pre>
<p><code>SyncedBuffer</code> 类型的值也是在声明时就分配好内存就绪了。后续代码中， <code>p</code> 和 <code>v</code> 无需进一步处理即可正确工作。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>p := <span class="hljs-built_in">new</span>(SyncedBuffer)  <span class="hljs-comment">// type *SyncedBuffer</span>
<span class="hljs-keyword">var</span> v SyncedBuffer      <span class="hljs-comment">// type  SyncedBuffer</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="70" data-paginate="true" data-theme="default" data-marpit-pagination="70" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>构造函数和复合字面量</h3>
<p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">File</span></span> {
    <span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    f := <span class="hljs-built_in">new</span>(File)
    f.fd = fd
    f.name = name
    f.dirinfo = <span class="hljs-literal">nil</span>
    f.nepipe = <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> f
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="71" data-paginate="true" data-theme="default" data-marpit-pagination="71" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这里显得代码过于冗长。我们可通过<strong>复合字面</strong>来简化它， 该表达式在每次求值时都会创建新的实例。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">File</span></span> {
    <span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    f := File{fd, name, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>}
    <span class="hljs-keyword">return</span> &amp;f
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="72" data-paginate="true" data-theme="default" data-marpit-pagination="72" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>请注意，返回一个局部变量的地址完全没有问题，这点与 C 不同。该局部变量对应的数据 在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">return</span> &amp;File{fd, name, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>}
</span></span></foreignObject></svg></code></pre>
<p>复合字面的字段必须按顺序全部列出。但如果以 <strong>字段</strong><code>:</code><strong>值</strong> 对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">return</span> &amp;File{fd: fd, name: name}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="73" data-paginate="true" data-theme="default" data-marpit-pagination="73" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>少数情况下，若复合字面不包括任何字段，它将创建该类型的零值。表达式 <code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。</p>
<p>复合字面同样可用于创建数组、切片以及映射，字段标签是索引还是映射键则视情况而定。 在下例初始化过程中，无论 <code>Enone</code>、<code>Eio</code> 和 <code>Einval</code> 的值是什么，只要它们的标签不同就行。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>a := [...]<span class="hljs-keyword">string</span>   {Enone: <span class="hljs-string">"no error"</span>, Eio: <span class="hljs-string">"Eio"</span>, Einval: <span class="hljs-string">"invalid argument"</span>}
s := []<span class="hljs-keyword">string</span>      {Enone: <span class="hljs-string">"no error"</span>, Eio: <span class="hljs-string">"Eio"</span>, Einval: <span class="hljs-string">"invalid argument"</span>}
m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>{Enone: <span class="hljs-string">"no error"</span>, Eio: <span class="hljs-string">"Eio"</span>, Einval: <span class="hljs-string">"invalid argument"</span>}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="74" data-paginate="true" data-theme="default" data-marpit-pagination="74" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>使用 <code>make</code> 分配</h3>
<p>再回到内存分配上来。内建函数 <code>make(T,</code><em>args</em><code>)</code> 的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个<strong>已初始化</strong> （而非<strong>置零</strong>）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量， 在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值。例如，</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="75" data-paginate="true" data-theme="default" data-marpit-pagination="75" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>会分配一个具有 100 个 <code>int</code> 的数组空间，接着创建一个长度为 10， 容量为 100 并指向该数组中前 10 个元素的切片结构。（生成切片时，其容量可以省略，更多信息见切片一节。） 与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已置零的切片结构， 即一个指向 <code>nil</code> 切片值的指针。</p>
<p>下面的例子阐明了 <code>new</code> 和 <code>make</code> 之间的区别：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> p *[]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-keyword">int</span>)       <span class="hljs-comment">// 分配切片结构；*p == nil；很少用到</span>
<span class="hljs-keyword">var</span> v  []<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 切片 v 现在引用了一个具有 100 个 int 元素的新数组</span>

<span class="hljs-comment">// 没必要的复杂用法:</span>
<span class="hljs-keyword">var</span> p *[]<span class="hljs-keyword">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-keyword">int</span>)
*p = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)

<span class="hljs-comment">// 常规用法:</span>
v := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)
</span></span></foreignObject></svg></code></pre>
<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="76" data-paginate="true" data-theme="default" data-marpit-pagination="76" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>数组</h3>
<p>在详细规划内存布局时，数组是非常有用的，有时还能避免过多的内存分配， 但它们主要用作切片的构件。这是下一节的主题了，不过要先说上几句来为它做铺垫。</p>
<p>以下为数组在 Go 和 C 中的主要区别。在 Go 中，</p>
<ul>
<li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>特别地，若将某个数组传入某个函数，它将接收到该数组的一份<strong>副本</strong>而非指针。</li>
<li>数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。</li>
</ul>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="77" data-paginate="true" data-theme="default" data-marpit-pagination="77" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a *[3]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">float64</span>)</span></span> {
    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> *a {
        sum += v
    }
    <span class="hljs-keyword">return</span>
}

array := [...]<span class="hljs-keyword">float64</span>{<span class="hljs-number">7.0</span>, <span class="hljs-number">8.5</span>, <span class="hljs-number">9.1</span>}
x := Sum(&amp;array)  <span class="hljs-comment">// Note the explicit address-of operator</span>
</span></span></foreignObject></svg></code></pre>
<p>但这并不是 Go 的习惯用法，切片才是。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="78" data-paginate="true" data-theme="default" data-marpit-pagination="78" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>切片</h3>
<p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go 中的大部分数组编程都是通过切片来完成的。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="79" data-paginate="true" data-theme="default" data-marpit-pagination="79" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。因此，<code>Read</code> 函数可接受一个切片实参 而非一个指针和一个计数；切片的长度决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code> 类型的 <code>Read</code> 方法签名:</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span> <span class="hljs-title">Read</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span>
</span></span></foreignObject></svg></code></pre>
<p>该方法返回读取的字节数和一个错误值（若有的话）。若要从更大的缓冲区 <code>b</code> 中读取前 32 个字节，只需对其进行<strong>切片</strong>即可。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    n, err := f.Read(buf[<span class="hljs-number">0</span>:<span class="hljs-number">32</span>])
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="80" data-paginate="true" data-theme="default" data-marpit-pagination="80" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这种切片的方法常用且高效。若不谈效率，以下片段同样能读取该缓冲区的前 32 个字节。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">var</span> n <span class="hljs-keyword">int</span>
    <span class="hljs-keyword">var</span> err error
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++ {
        nbytes, e := f.Read(buf[i:i+<span class="hljs-number">1</span>])  <span class="hljs-comment">// Read one byte.</span>
        n += nbytes
        <span class="hljs-keyword">if</span> nbytes == <span class="hljs-number">0</span> || e != <span class="hljs-literal">nil</span> {
            err = e
            <span class="hljs-keyword">break</span>
        }
    }
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="81" data-paginate="true" data-theme="default" data-marpit-pagination="81" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。 切片的<strong>容量</strong>可通过内建函数 <code>cap</code> 获得，它将给出该切片可取得的最大长度。 以下是将数据追加到切片的函数。若数据超出其容量，则会重新分配该切片。返回值即为所得的切片。 该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code> 切片时是合法的，它会返回 0。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Append</span><span class="hljs-params">(slice, data []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> {
    l := <span class="hljs-built_in">len</span>(slice)
    <span class="hljs-keyword">if</span> l + <span class="hljs-built_in">len</span>(data) &gt; <span class="hljs-built_in">cap</span>(slice) {  <span class="hljs-comment">// 重新分配</span>
        <span class="hljs-comment">// 为未来的增长,双重分配所需的内容.</span>
        newSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, (l+<span class="hljs-built_in">len</span>(data))*<span class="hljs-number">2</span>)
        <span class="hljs-comment">// copy函数是预先声明的，适用于任何切片类型。</span>
        <span class="hljs-built_in">copy</span>(newSlice, slice)
        slice = newSlice
    }
    slice = slice[<span class="hljs-number">0</span>:l+<span class="hljs-built_in">len</span>(data)]
    <span class="hljs-built_in">copy</span>(slice[l:], data)
    <span class="hljs-keyword">return</span> slice
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="82" data-paginate="true" data-theme="default" data-marpit-pagination="82" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>最终我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code> 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p>
<p>向切片追加东西的想法非常有用，因此有专门的内建函数 <code>append</code>。 要理解该函数的设计，我们还需要一些额外的信息，我们将稍后再介绍它。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="83" data-paginate="true" data-theme="default" data-marpit-pagination="83" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>二维切片</h3>
<p>Go 的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片，就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Transform [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-keyword">float64</span>  <span class="hljs-comment">// 一个 3x3 的数组，其实是包含多个数组的一个数组。</span>
<span class="hljs-keyword">type</span> LinesOfText [][]<span class="hljs-keyword">byte</span>     <span class="hljs-comment">// 包含多个字节切片的一个切片。</span>
</span></span></foreignObject></svg></code></pre>
<p>由于切片长度是可变的，因此其内部可能拥有多个不同长度的切片。在我们的 <code>LinesOfText</code> 例子中，这是种常见的情况：每行都有其自己的长度。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>text := LinesOfText{
    []<span class="hljs-keyword">byte</span>(<span class="hljs-string">"Now is the time"</span>),
    []<span class="hljs-keyword">byte</span>(<span class="hljs-string">"for all good gophers"</span>),
    []<span class="hljs-keyword">byte</span>(<span class="hljs-string">"to bring some fun to the party."</span>),
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="84" data-paginate="true" data-theme="default" data-marpit-pagination="84" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>有时必须分配一个二维数组，例如在处理像素的扫描行时，这种情况就会发生。 我们有两种方式来达到这个目的。一种就是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它。采用哪种方式取决于你的应用。若切片会增长或收缩， 就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更加高效。 以下是这两种方法的大概代码，仅供参考。首先是一次一行的：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 分配底层切片.</span>
picture := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">uint8</span>, YSize) <span class="hljs-comment">// y每一行的大小</span>
<span class="hljs-comment">//循环遍历每一行</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> picture {
    picture[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint8</span>, XSize)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="85" data-paginate="true" data-theme="default" data-marpit-pagination="85" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>现在是一次分配，对行进行切片：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 分配底层切片</span>
picture := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">uint8</span>, YSize) <span class="hljs-comment">//  每 y 个单元一行。</span>
<span class="hljs-comment">// 分配一个大一些的切片以容纳所有的元素</span>
pixels := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint8</span>, XSize*YSize) <span class="hljs-comment">// 指定类型[]uint8, 即便图片是 [][]uint8.</span>
<span class="hljs-comment">//循环遍历图片所有行，从剩余像素切片的前面对每一行进行切片。</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="86" data-paginate="true" data-theme="default" data-marpit-pagination="86" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>映射</h3>
<p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样，映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="87" data-paginate="true" data-theme="default" data-marpit-pagination="87" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>映射可使用一般的复合字面语法进行构建，其键 - 值对使用冒号分隔，因此可在初始化时很容易地构建它们。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> timeZone = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>{
    <span class="hljs-string">"UTC"</span>:  <span class="hljs-number">0</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,
    <span class="hljs-string">"EST"</span>: <span class="hljs-number">-5</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,
    <span class="hljs-string">"CST"</span>: <span class="hljs-number">-6</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,
    <span class="hljs-string">"MST"</span>: <span class="hljs-number">-7</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,
    <span class="hljs-string">"PST"</span>: <span class="hljs-number">-8</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,
}
</span></span></foreignObject></svg></code></pre>
<p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>offset := timeZone[<span class="hljs-string">"EST"</span>]
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="88" data-paginate="true" data-theme="default" data-marpit-pagination="88" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。 例如，若某个映射包含整数，当查找一个不存在的键时会返回 <code>0</code>。 集合可实现成一个值类型为 <code>bool</code> 的映射。将该映射中的项置为 <code>true</code> 可将该值放入集合中，此后通过简单的索引操作即可判断是否存在。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>attended := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>{
    <span class="hljs-string">"Ann"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"Joe"</span>: <span class="hljs-literal">true</span>,
    ...
}

<span class="hljs-keyword">if</span> attended[person] { <span class="hljs-comment">// person不在集合中，返回 false</span>
    fmt.Println(person, <span class="hljs-string">"was at the meeting"</span>)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="89" data-paginate="true" data-theme="default" data-marpit-pagination="89" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>有时你需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>&quot;UTC&quot;</code> 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> seconds <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> ok <span class="hljs-keyword">bool</span>
seconds, ok = timeZone[tz]
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="90" data-paginate="true" data-theme="default" data-marpit-pagination="90" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>显然，我们可称之为 “逗号 ok” 惯用法。在下面的例子中，若 <code>tz</code> 存在， <code>seconds</code> 就会被赋予适当的值，且 <code>ok</code> 会被置为 <code>true</code>； 若不存在，<code>seconds</code> 则会被置为零，而 <code>ok</code> 会被置为 <code>false</code>。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">offset</span><span class="hljs-params">(tz <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">if</span> seconds, ok := timeZone[tz]; ok {
        <span class="hljs-keyword">return</span> seconds
    }
    log.Println(<span class="hljs-string">"unknown time zone:"</span>, tz)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="91" data-paginate="true" data-theme="default" data-marpit-pagination="91" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用<a href="https://learnku.com/docs/effective-go/blank-identifier/6247">空白标识符</a> （<code>_</code>）来代替该值的一般变量。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>_, present := timeZone[tz]
</span></span></foreignObject></svg></code></pre>
<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-built_in">delete</span>(timeZone, <span class="hljs-string">"PDT"</span>)  <span class="hljs-comment">// 现在是标准时间</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="92" data-paginate="true" data-theme="default" data-marpit-pagination="92" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>打印</h3>
<p>Go 采用的格式化打印风格和 C 的 <code>printf</code> 族类似，但却更加丰富而通用。 这些函数位于 <code>fmt</code> 包中，且函数名首字母均为大写：如 <code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。 字符串函数（<code>Sprintf</code> 等）会返回一个字符串，而非填充给定的缓冲区。</p>
<p>你无需提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和 <code>Sprintf</code> 都分别对应另外的函数，如 <code>Print</code> 与 <code>Println</code>。 这些函数并不接受格式字符串，而是为每个实参生成一种默认格式。<code>Println</code> 系列的函数还会在实参中插入空格，并在输出时追加一个换行符，而 <code>Print</code> 版本仅在操作数两侧都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="93" data-paginate="true" data-theme="default" data-marpit-pagination="93" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>fmt.Printf(<span class="hljs-string">"Hello %d\n"</span>, <span class="hljs-number">23</span>)
fmt.Fprint(os.Stdout, <span class="hljs-string">"Hello "</span>, <span class="hljs-number">23</span>, <span class="hljs-string">"\n"</span>)
fmt.Println(<span class="hljs-string">"Hello"</span>, <span class="hljs-number">23</span>)
fmt.Println(fmt.Sprint(<span class="hljs-string">"Hello "</span>, <span class="hljs-number">23</span>))
</span></span></foreignObject></svg></code></pre>
<p><code>fmt.Fprint</code> 一类的格式化打印函数可接受任何实现了 <code>io.Writer</code> 接口的对象作为第一个实参；变量 <code>os.Stdout</code> 与 <code>os.Stderr</code> 都是人们熟知的例子。</p>
<p>从这里开始，就与 C 有些不同了。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记， 打印例程会根据实参的类型来决定这些属性。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> x <span class="hljs-keyword">uint64</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">64</span> - <span class="hljs-number">1</span>
fmt.Printf(<span class="hljs-string">"%d %x; %d %x\n"</span>, x, x, <span class="hljs-keyword">int64</span>(x), <span class="hljs-keyword">int64</span>(x))
</span></span></foreignObject></svg></code></pre>
<p>打印结果</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-number">18446744073709551615</span> ffffffffffffffff; <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="94" data-paginate="true" data-theme="default" data-marpit-pagination="94" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式 <code>%v</code>（对应 “值”）；其结果与 <code>Print</code> 和 <code>Println</code> 的输出完全相同。此外，这种格式还能打印<strong>任意</strong>值，甚至包括数组、结构体和映射。 以下是打印上一节中定义的时区映射的语句。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>fmt.Printf(<span class="hljs-string">"%v\n"</span>, timeZone)  <span class="hljs-comment">// or just fmt.Println(timeZone)</span>
</span></span></foreignObject></svg></code></pre>
<p>打印结果:</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">map</span>[CST:<span class="hljs-number">-21600</span> EST:<span class="hljs-number">-18000</span> MST:<span class="hljs-number">-25200</span> PST:<span class="hljs-number">-28800</span> UTC:<span class="hljs-number">0</span>]
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="95" data-paginate="true" data-theme="default" data-marpit-pagination="95" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>对于映射，<code>Printf</code> 会自动对映射值按照键的字典顺序排序。</p>
<p>当然，映射中的键可能按任意顺序输出。当打印结构体时，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，而另一种格式 <code>%#v</code> 将完全按照 Go 的语法打印值。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> {
    a <span class="hljs-keyword">int</span>
    b <span class="hljs-keyword">float64</span>
    c <span class="hljs-keyword">string</span>
}
t := &amp;T{ <span class="hljs-number">7</span>, <span class="hljs-number">-2.35</span>, <span class="hljs-string">"abc\tdef"</span> }
fmt.Printf(<span class="hljs-string">"%v\n"</span>, t)
fmt.Printf(<span class="hljs-string">"%+v\n"</span>, t)
fmt.Printf(<span class="hljs-string">"%#v\n"</span>, t)
fmt.Printf(<span class="hljs-string">"%#v\n"</span>, timeZone)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="96" data-paginate="true" data-theme="default" data-marpit-pagination="96" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>将打印</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>&amp;{<span class="hljs-number">7</span> <span class="hljs-number">-2.35</span> abc   def}
&amp;{a:<span class="hljs-number">7</span> b:<span class="hljs-number">-2.35</span> c:abc     def}
&amp;main.T{a:<span class="hljs-number">7</span>, b:<span class="hljs-number">-2.35</span>, c:<span class="hljs-string">"abc\tdef"</span>}
<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>{<span class="hljs-string">"CST"</span>:<span class="hljs-number">-21600</span>, <span class="hljs-string">"EST"</span>:<span class="hljs-number">-18000</span>, <span class="hljs-string">"MST"</span>:<span class="hljs-number">-25200</span>, <span class="hljs-string">"PST"</span>:<span class="hljs-number">-28800</span>, <span class="hljs-string">"UTC"</span>:<span class="hljs-number">0</span>}
</span></span></foreignObject></svg></code></pre>
<p>（请注意其中的 &amp; 符号）当遇到 <code>string</code> 或 <code>[]byte</code> 值时， 可使用 <code>%q</code> 产生带引号的字符串；而格式 <code>%#q</code> 会尽可能使用反引号。 （<code>%q</code> 格式也可用于整数和符文，它会产生一个带单引号的符文常量。） 此外，<code>%x</code> 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串， 而带空格的格式（<code>% x</code>）还会在字节之间插入空格。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="97" data-paginate="true" data-theme="default" data-marpit-pagination="97" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>另一种实用的格式是 <code>%T</code>，它会打印某个值的<strong>类型</strong>。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>fmt.Printf(<span class="hljs-string">"%T\n"</span>, timeZone)
</span></span></foreignObject></svg></code></pre>
<p>会打印</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="98" data-paginate="true" data-theme="default" data-marpit-pagination="98" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%d/%g/%q"</span>, t.a, t.b, t.c)
}
fmt.Printf(<span class="hljs-string">"%v\n"</span>, t)
</span></span></foreignObject></svg></code></pre>
<p>会打印出如下格式：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-number">7</span>/<span class="hljs-number">-2.35</span>/<span class="hljs-string">"abc\tdef"</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="99" data-paginate="true" data-theme="default" data-marpit-pagination="99" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>（如果你需要像指向 <code>T</code> 的指针那样打印类型 <code>T</code> 的<strong>值</strong>， <code>String</code> 的接收者就必须是值类型的；上面的例子中接收者是一个指针， 因为这对结构来说更高效而通用。更多详情见<a href="https://learnku.com/docs/effective-go/method/6245#20ffd5">指针 vs. 值接收者</a>一节）</p>
<p>我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>， 因为打印例程可以完全重入并按这种方式封装。不过有一个重要的细节你需要知道： 请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code> 方法，因为它会无限递归你的的 <code>String</code> 方法。如果 <code>Sprintf</code> 调用试图将接收器直接打印为字符串，而该字符串又将再次调用该方法，则会发生这种情况。这是一个常见的错误，如本例所示。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> MyString <span class="hljs-keyword">string</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyString)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"MyString=%s"</span>, m) <span class="hljs-comment">// 错误：会无限递归</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="100" data-paginate="true" data-theme="default" data-marpit-pagination="100" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> MyString <span class="hljs-keyword">string</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyString)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"MyString=%s"</span>, <span class="hljs-keyword">string</span>(m)) <span class="hljs-comment">// 可以：注意转换</span>
}
</span></span></foreignObject></svg></code></pre>
<p>在 <a href="https://learnku.com/docs/effective-go/initialization/6244">初始化</a> 一节中，我们将看到避免这种递归的另一种技术。</p>
<p>另一种打印技术就是将打印例程的实参直接传入另一个这样的例程。<code>Printf</code> 的签名为其最后的实参使用了 <code>...interface{}</code> 类型，这样格式的后面就能出现任意数量，任意类型的形参了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Printf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, v ...<span class="hljs-keyword">interface</span>{})</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> {
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="101" data-paginate="true" data-theme="default" data-marpit-pagination="101" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>在 <code>Printf</code> 函数中，<code>v</code> 看起来更像是 <code>[]interface{}</code> 类型的变量，但如果将它传递到另一个变参函数中，它就像是常规实参列表了。 以下是我们之前用过的 <code>log.Println</code> 的实现。它直接将其实参传递给 <code>fmt.Sprintln</code> 进行实际的格式化。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// Println 通过 fmt.Println 的方式将日志打印到标准记录器</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Println</span><span class="hljs-params">(v ...<span class="hljs-keyword">interface</span>{})</span></span> {
    std.Output(<span class="hljs-number">2</span>, fmt.Sprintln(v...))  <span class="hljs-comment">// Output takes parameters (int, string)</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="102" data-paginate="true" data-theme="default" data-marpit-pagination="102" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>在该 <code>Sprintln</code> 嵌套调用中，我们将 <code>...</code> 写在 <code>v</code> 之后来告诉编译器将 <code>v</code> 视作一个实参列表，否则它会将 <code>v</code> 当做单一的切片实参来传递。</p>
<p>还有很多关于打印知识点没有提及。详情请参阅 <code>godoc</code> 对 <code>fmt</code> 包的说明文档。</p>
<p>顺便一提，<code>...</code> 形参可指定具体的类型，例如从整数列表中选出最小值的函数 <code>min</code>，其形参可为 <code>...int</code> 类型。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    min := <span class="hljs-keyword">int</span>(^<span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 最大的 int</span>
    <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> a {
        <span class="hljs-keyword">if</span> i &lt; min {
            min = i
        }
    }
    <span class="hljs-keyword">return</span> min
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="103" data-paginate="true" data-theme="default" data-marpit-pagination="103" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>追加</h3>
<p>现在我们要对内建函数 <code>append</code> 的设计进行补充说明。<code>append</code> 函数的签名不同于前面我们自定义的 <code>Append</code> 函数。大致来说，它就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []T, elements ...T)</span> []<span class="hljs-title">T</span></span>
</span></span></foreignObject></svg></code></pre>
<p>其中的 <em>T</em> 为任意给定类型的占位符。实际上，你无法在 Go 中编写一个类型 <code>T</code> 由调用者决定的函数。这也就是为何 <code>append</code> 为内建函数的原因：它需要编译器的支持。</p>
<p><code>append</code> 会在切片末尾追加元素并返回结果。我们必须返回结果， 原因与我们手写的 <code>Append</code> 一样，即底层数组可能会被改变。以下简单的例子</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>x := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}
x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
fmt.Println(x)
</span></span></foreignObject></svg></code></pre>
<p>将打印 <code>[1 2 3 4 5 6]</code>。因此 <code>append</code> 有点像 <code>Printf</code> 那样，可接受任意数量的实参。</p>
<p>但如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>x := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}
y := []<span class="hljs-keyword">int</span>{<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}
x = <span class="hljs-built_in">append</span>(x, y...)
fmt.Println(x)
</span></span></foreignObject></svg></code></pre>
<p>如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code> 不是 <code>int</code> 类型的。</p>
<h2>初始化</h2>
<p>尽管从表面上看，Go 的初始化过程与 C 或 C++ 差别并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p>
<h3>常量</h3>
<p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code> 则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。</p>
<p>在 Go 中，枚举常量使用枚举器 <code>iota</code> 创建。由于 <code>iota</code> 可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> ByteSize <span class="hljs-keyword">float64</span>

<span class="hljs-keyword">const</span> (
    _           = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 通过赋予空白标识符来忽略第一个值</span>
    KB ByteSize = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</span></span></foreignObject></svg></code></pre>
<p>由于可将 <code>String</code> 之类的方法附加在用户定义的类型上， 因此它就为打印时自动格式化任意值提供了可能性，即便是作为一个通用类型的一部分。 尽管你常常会看到这种技术应用于结构体，但它对于像 <code>ByteSize</code> 之类的浮点数标量等类型也是有用的。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b ByteSize)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">switch</span> {
    <span class="hljs-keyword">case</span> b &gt;= YB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fYB"</span>, b/YB)
    <span class="hljs-keyword">case</span> b &gt;= ZB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fZB"</span>, b/ZB)
    <span class="hljs-keyword">case</span> b &gt;= EB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fEB"</span>, b/EB)
    <span class="hljs-keyword">case</span> b &gt;= PB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fPB"</span>, b/PB)
    <span class="hljs-keyword">case</span> b &gt;= TB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fTB"</span>, b/TB)
    <span class="hljs-keyword">case</span> b &gt;= GB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fGB"</span>, b/GB)
    <span class="hljs-keyword">case</span> b &gt;= MB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fMB"</span>, b/MB)
    <span class="hljs-keyword">case</span> b &gt;= KB:
        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fKB"</span>, b/KB)
    }
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%.2fB"</span>, b)
}
</span></span></foreignObject></svg></code></pre>
<p>表达式 <code>YB</code> 会打印出 <code>1.00YB</code>，而 <code>ByteSize(1e13)</code> 则会打印出 <code>9.09</code>。</p>
<p>在这里用 <code>Sprintf</code> 实现 <code>ByteSize</code> 的 <code>String</code> 方法很安全（不会无限递归），这倒不是因为类型转换，而是它以 <code>%f</code> 调用了 <code>Sprintf</code>，它并不是一种字符串格式：<code>Sprintf</code> 只会在它需要字符串时才调用 <code>String</code> 方法，而 <code>%f</code> 需要一个浮点数值。</p>
<h3>变量</h3>
<p>变量能像常量一样初始化，而且可以初始化为一个可在运行时得出结果的普通表达式。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> (
    home   = os.Getenv(<span class="hljs-string">"HOME"</span>)
    user   = os.Getenv(<span class="hljs-string">"USER"</span>)
    gopath = os.Getenv(<span class="hljs-string">"GOPATH"</span>)
)
</span></span></foreignObject></svg></code></pre>
<h3>init 函数</h3>
<p>最后，每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而那些 <code>init</code> 只有在所有已导入的包都被初始化后才会被求值。</p>
<p>除了那些不能被表示成声明的初始化外，<code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> user == <span class="hljs-string">""</span> {
        log.Fatal(<span class="hljs-string">"$USER not set"</span>)
    }
    <span class="hljs-keyword">if</span> home == <span class="hljs-string">""</span> {
        home = <span class="hljs-string">"/home/"</span> + user
    }
    <span class="hljs-keyword">if</span> gopath == <span class="hljs-string">""</span> {
        gopath = home + <span class="hljs-string">"/go"</span>
    }
    <span class="hljs-comment">// gopath 可通过命令行中的 --gopath 标记覆盖掉。</span>
    flag.StringVar(&amp;gopath, <span class="hljs-string">"gopath"</span>, gopath, <span class="hljs-string">"override default GOPATH"</span>)
}
</span></span></foreignObject></svg></code></pre>
<h2>方法</h2>
<h3>指针 vs. 值</h3>
<p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>
<p>在之前讨论切片时，我们编写了一个 <code>Append</code> 函数。 我们也可将其定义为切片的方法。为此，我们首先要声明一个已命名的类型来绑定该方法， 然后使该方法的接收者成为该类型的值。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> ByteSlice []<span class="hljs-keyword">byte</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(slice ByteSlice)</span> <span class="hljs-title">Append</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> {
    <span class="hljs-comment">// 主体与上面定义的Append函数完全相同。</span>
}
</span></span></foreignObject></svg></code></pre>
<p>我们仍然需要该方法返回更新后的切片。为了消除这种不便，我们可通过重新定义该方法， 将一个指向 <code>ByteSlice</code> 的<strong>指针</strong>作为该方法的接收者， 这样该方法就能重写调用者提供的切片了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ByteSlice)</span> <span class="hljs-title">Append</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span></span> {
    slice := *p
    <span class="hljs-comment">// 主体同上，只是没有返回值</span>
    *p = slice
}
</span></span></foreignObject></svg></code></pre>
<p>其实我们做得更好。若我们将函数修改为与标准 <code>Write</code> 类似的方法，就像这样，</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ByteSlice)</span> <span class="hljs-title">Write</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> {
    slice := *p
    <span class="hljs-comment">// 同上。</span>
    *p = slice
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(data), <span class="hljs-literal">nil</span>
}
</span></span></foreignObject></svg></code></pre>
<p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常实用。 例如，我们可以通过打印将内容写入。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>    <span class="hljs-keyword">var</span> b ByteSlice
    fmt.Fprintf(&amp;b, <span class="hljs-string">"This hour has %d days\n"</span>, <span class="hljs-number">7</span>)
</span></span></foreignObject></svg></code></pre>
<p>我们将 <code>ByteSlice</code> 的地址传入，因为只有 <code>*ByteSlice</code> 才满足 <code>io.Writer</code>。以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>
<p>之所以会有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。不过有个方便的例外：若该值是可寻址的， 那么该语言就会自动插入取址操作符来对付一般的通过值调用的指针方法。在我们的例子中，变量 <code>b</code> 是可寻址的，因此我们只需通过 <code>b.Write</code> 来调用它的 <code>Write</code> 方法，编译器会将它重写为 <code>(&amp;b).Write</code>。</p>
<p>顺便一提，在字节切片上使用 <code>Write</code> 的想法已被 <code>bytes.Buffer</code> 所实现。</p>
<h2>接口与其它类型</h2>
<h3>接口</h3>
<p>Go 中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成<strong>这个</strong>， 那么它就可以用在<strong>这里</strong>。我们已经见过许多简单的示例了；通过实现 <code>String</code> 方法，我们可以自定义打印函数，而通过 <code>Write</code> 方法，<code>Fprintf</code> 则能对任何对象产生输出。在 Go 代码中， 仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法， 如 <code>io.Writer</code> 就是实现了 <code>Write</code> 的一类对象。</p>
<p>每种类型都能实现多个接口。例如一个实现了 <code>sort.Interface</code> 接口的集合就可通过 <code>sort</code> 包中的例程进行排序。该接口包括 <code>Len()</code>、<code>Less(i, j int) bool</code> 以及 <code>Swap(i, j int)</code>，另外，该集合仍然可以有一个自定义的格式化器。 以下特意构建的例子 <code>Sequence</code> 就同时满足这两种情况。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Sequence []<span class="hljs-keyword">int</span>

<span class="hljs-comment">// sort.Interface所需的方法。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">return</span> s[i] &lt; s[j]
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> {
    s[i], s[j] = s[j], s[i]
}

<span class="hljs-comment">// Copy方法返回Sequence的复制</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">Copy</span><span class="hljs-params">()</span> <span class="hljs-title">Sequence</span></span> {
    <span class="hljs-built_in">copy</span> := <span class="hljs-built_in">make</span>(Sequence, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s))
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(<span class="hljs-built_in">copy</span>, s...)
}

<span class="hljs-comment">// 打印方法-在打印前给元素排序</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    s = s.Copy() <span class="hljs-comment">// 复制s，不要覆盖参数本身</span>
    sort.Sort(s)
    str := <span class="hljs-string">"["</span>
    <span class="hljs-keyword">for</span> i, elem := <span class="hljs-keyword">range</span> s { <span class="hljs-comment">// Loop空间复杂度是O(N²)；将在下个例子中修复它</span>
        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {
            str += <span class="hljs-string">" "</span>
        }
        str += fmt.Sprint(elem)
    }
    <span class="hljs-keyword">return</span> str + <span class="hljs-string">"]"</span>
}
</span></span></foreignObject></svg></code></pre>
<h3>类型转换</h3>
<p><code>Sequence</code> 的 <code>String</code> 方法重新实现了 <code>Sprint</code> 为切片实现的功能。若我们在调用 <code>Sprint</code> 之前将 <code>Sequence</code> 转换为纯粹的 <code>[]int</code>，就能共享已实现的功能。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    s = s.Copy()
    sort.Sort(s)
    <span class="hljs-keyword">return</span> fmt.Sprint([]<span class="hljs-keyword">int</span>(s))
}
</span></span></foreignObject></svg></code></pre>
<p>该方法是通过类型转换技术，在 <code>String</code> 方法中安全调用 <code>Sprintf</code> 的另个一例子。若我们忽略类型名的话，这两种类型（<code>Sequence</code> 和 <code>[]int</code>）其实是相同的，因此在二者之间进行转换是合法的。 转换过程并不会创建新值，它只是值暂让现有的时看起来有个新类型而已。 （还有些合法转换则会创建新值，如从整数转换为浮点数等。）</p>
<p>在 Go 程序中，为访问不同的方法集而进行类型转换的情况非常常见。 例如，我们可使用现有的 <code>sort.IntSlice</code> 类型来简化整个示例：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Sequence []<span class="hljs-keyword">int</span>

<span class="hljs-comment">// 打印方法-在打印之前对元素进行排序</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Sequence)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    s = s.Copy()
    sort.IntSlice(s).Sort()
    <span class="hljs-keyword">return</span> fmt.Sprint([]<span class="hljs-keyword">int</span>(s))
}
</span></span></foreignObject></svg></code></pre>
<p>现在，不必让 <code>Sequence</code> 实现多个接口（排序和打印）， 我们可通过将数据条目转换为多种类型（<code>Sequence</code>、<code>sort.IntSlice</code> 和 <code>[]int</code>）来使用相应的功能，每次转换都完成一部分工作。 这在实践中虽然有些不同寻常，但往往却很有效。</p>
<h3>接口转换与类型断言</h3>
<p><a href="https://learnku.com/docs/effective-go/control-structure/6241#bca1f2">类型选择</a> 是类型转换的一种形式：它接受一个接口，在选择 （switch）中根据其判断选择对应的情况（case）， 并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值； 若它有 String 方法，我们则需要调用该方法所得的结果。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> {
    String() <span class="hljs-keyword">string</span>
}

<span class="hljs-keyword">var</span> value <span class="hljs-keyword">interface</span>{} <span class="hljs-comment">// Value 由调用者提供</span>
<span class="hljs-keyword">switch</span> str := value.(<span class="hljs-keyword">type</span>) {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:
    <span class="hljs-keyword">return</span> str
<span class="hljs-keyword">case</span> Stringer:
    <span class="hljs-keyword">return</span> str.String()
}
</span></span></foreignObject></svg></code></pre>
<p>第一种情况获取具体的值，第二种将该接口转换为另一个接口。这种方式对于混合类型来说非常完美。</p>
<p>若我们只关心一种类型呢？若我们知道该值拥有一个 <code>string</code> 而想要提取它呢？ 只需一种情况的类型选择就行，但它需要<strong>类型断言</strong>。类型断言接受一个接口值， 并从中提取指定的明确类型的值。其语法借鉴自类型选择开头的子句，但它需要一个明确的类型， 而非 <code>type</code> 关键字：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>value.(typeName)
</span></span></foreignObject></svg></code></pre>
<p>而其结果则是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型， 或者该值可转换成的第二种接口类型。要提取我们知道在该值中的字符串，可以这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>str := value.(<span class="hljs-keyword">string</span>)
</span></span></foreignObject></svg></code></pre>
<p>但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用 “逗号，ok” 惯用测试它能安全地判断该值是否为字符串：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>str, ok := value.(<span class="hljs-keyword">string</span>)
<span class="hljs-keyword">if</span> ok {
    fmt.Printf(<span class="hljs-string">"string value is: %q\n"</span>, str)
} <span class="hljs-keyword">else</span> {
    fmt.Printf(<span class="hljs-string">"value is not a string\n"</span>)
}
</span></span></foreignObject></svg></code></pre>
<p>若类型断言失败，str 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p>
<p>作为对能量的说明，这里有个 if-else 语句，它等价于本节开头的类型选择。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> str, ok := value.(<span class="hljs-keyword">string</span>); ok {
    <span class="hljs-keyword">return</span> str
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> str, ok := value.(Stringer); ok {
    <span class="hljs-keyword">return</span> str.String()
}
</span></span></foreignObject></svg></code></pre>
<h3>通用性</h3>
<p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code> 库中，<code>crc32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型 <code>hash.Hash32</code>。要在 Go 程序中用 Adler-32 算法替代 CRC-32， 只需修改构造函数调用即可，其余代码则不受算法改变的影响。</p>
<p>同样的方式能将 <code>crypto</code> 包中多种联系在一起的流密码算法与块密码算法分开。 <code>crypto/cipher</code> 包中的 <code>Block</code> 接口指定了块密码算法的行为， 它为单独的数据块提供加密。接着，和 <code>bufio</code> 包类似，任何实现了该接口的密码包都能被用于构造以 <code>Stream</code> 为接口表示的流密码，而无需知道块加密的细节。</p>
<p><code>crypto/cipher</code> 接口看其来就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Block <span class="hljs-keyword">interface</span> {
    BlockSize() <span class="hljs-keyword">int</span>
    Encrypt(dst, src []<span class="hljs-keyword">byte</span>)
    Decrypt(dst, src []<span class="hljs-keyword">byte</span>)
}

<span class="hljs-keyword">type</span> Stream <span class="hljs-keyword">interface</span> {
    XORKeyStream(dst, src []<span class="hljs-keyword">byte</span>)
}
</span></span></foreignObject></svg></code></pre>
<p>这是计数器模式 CTR 流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// NewCTR 返回使用中给定的块加密/解密的流</span>
<span class="hljs-comment">// 计数器模式。iv 的长度必须与块的块大小相同</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCTR</span><span class="hljs-params">(block Block, iv []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">Stream</span></span>
</span></span></foreignObject></svg></code></pre>
<p><code>NewCTR</code> 的应用并不仅限于特定的加密算法和数据源，它适用于任何对 <code>Block</code> 接口和 <code>Stream</code> 的实现。因为它们返回接口值， 所以用其它加密模式来代替 CTR 只需做局部的更改。构造函数的调用过程必须被修改， 但由于其周围的代码只能将它看做 <code>Stream</code>，因此它们不会注意到其中的区别。</p>
<h3>接口和方法</h3>
<p>由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。一个很直观的例子就是 <code>http</code> 包中定义的 <code>Handler</code> 接口。任何实现了 <code>Handler</code> 的对象都能够处理 HTTP 请求。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> {
    ServeHTTP(ResponseWriter, *Request)
}
</span></span></foreignObject></svg></code></pre>
<p><code>ResponseWriter</code> 接口提供了对方法的访问，这些方法需要响应客户端的请求。 由于这些方法包含了标准的 <code>Write</code> 方法，因此 <code>http.ResponseWriter</code> 可用于任何 <code>io.Writer</code> 适用的场景。<code>Request</code> 结构体包含已解析的客户端请求。</p>
<p>为简单起见，我们假设所有的 HTTP 请求都是 GET 方法，而忽略 POST 方法， 这种简化不会影响处理程序的建立方式。这里有个短小却完整的处理程序实现， 它用于记录某个页面被访问的次数。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 简单的计数器服务器。</span>
<span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> {
    n <span class="hljs-keyword">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctr *Counter)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
    ctr.n++
    fmt.Fprintf(w, <span class="hljs-string">"counter = %d\n"</span>, ctr.n)
}
</span></span></foreignObject></svg></code></pre>
<p>（紧跟我们的主题，注意 Fprintf 如何能输出到 http.ResponseWriter。） 作为参考，这里演示了如何将这样一个服务器添加到 URL 树的一个节点上。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">import</span> <span class="hljs-string">"net/http"</span>
...
ctr := <span class="hljs-built_in">new</span>(Counter)
http.Handle(<span class="hljs-string">"/counter"</span>, ctr)
</span></span></foreignObject></svg></code></pre>
<p>但为什么 <code>Counter</code> 要是结构体呢？一个整数就够了。（接收者必须为指针，增量操作对于调用者才可见。）</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 简单的计数器服务。</span>
<span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctr *Counter)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
    *ctr++
    fmt.Fprintf(w, <span class="hljs-string">"counter = %d\n"</span>, *ctr)
}
</span></span></foreignObject></svg></code></pre>
<p>当页面被访问时，怎样通知你的程序去更新一些内部状态呢？为 Web 页面绑定个信道吧。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 每次浏览该信道都会发送一个提醒。</span>
<span class="hljs-comment">// （可能需要带缓冲的信道。）</span>
<span class="hljs-keyword">type</span> Chan <span class="hljs-keyword">chan</span> *http.Request

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ch Chan)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
    ch &lt;- req
    fmt.Fprint(w, <span class="hljs-string">"notification sent"</span>)
}
</span></span></foreignObject></svg></code></pre>
<p>最后，假设我们需要输出调用服务器二进制程序时使用的实参 <code>/args</code>。 很简单，写个打印实参的函数就行了。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ArgServer</span><span class="hljs-params">()</span></span> {
    fmt.Println(os.Args)
}
</span></span></foreignObject></svg></code></pre>
<p>我们如何将它转换为 HTTP 服务器呢？我们可以将 <code>ArgServer</code> 实现为某种可忽略值的方法，不过还有种更简单的方法。 既然我们可以为除指针和接口以外的任何类型定义方法，同样也能为一个函数写一个方法。 <code>http</code> 包包含以下代码：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// HandlerFunc 类型是一个适配器，</span>
<span class="hljs-comment">// 它允许将普通函数用做HTTP处理程序。</span>
<span class="hljs-comment">// 若 f 是个具有适当签名的函数，</span>
<span class="hljs-comment">// HandlerFunc(f) 就是个调用 f 的处理程序对象。</span>
<span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span>

<span class="hljs-comment">// ServeHTTP calls f(w, req).</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, req *Request)</span></span> {
    f(w, req)
}
</span></span></foreignObject></svg></code></pre>
<p><code>HandlerFunc</code> 是个具有 <code>ServeHTTP</code> 方法的类型， 因此该类型的值就能处理 HTTP 请求。我们来看看该方法的实现：接收者是一个函数 <code>f</code>，而该方法调用 <code>f</code>。这看起来很奇怪，但不必大惊小怪， 区别在于接收者变成了一个信道，而方法通过该信道发送消息。</p>
<p>为了将 <code>ArgServer</code> 实现成 HTTP 服务器，首先我们得让它拥有合适的签名。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 实参服务器。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ArgServer</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
    fmt.Fprintln(w, os.Args)
}
</span></span></foreignObject></svg></code></pre>
<p><code>ArgServer</code> 和 <code>HandlerFunc</code> 现在拥有了相同的签名， 因此我们可将其转换为这种类型以访问它的方法，就像我们将 <code>Sequence</code> 转换为 <code>IntSlice</code> 以访问 <code>IntSlice.Sort</code> 那样。 建立代码非常简单：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>http.Handle(<span class="hljs-string">"/args"</span>, http.HandlerFunc(ArgServer))
</span></span></foreignObject></svg></code></pre>
<p>当有人访问 <code>/args</code> 页面时，安装到该页面的处理程序就有了值 <code>ArgServer</code> 和类型 <code>HandlerFunc</code>。 HTTP 服务器会以 <code>ArgServer</code> 为接收者，调用该类型的 <code>ServeHTTP</code> 方法，它会反过来调用 <code>ArgServer</code>（通过 <code>f(c, req)</code>），接着实参就会被显示出来。</p>
<p>在本节中，我们通过一个结构体，一个整数，一个信道和一个函数，建立了一个 HTTP 服务器， 这一切都是因为接口只是方法的集和，而几乎任何类型都能定义方法。</p>
<h2>空白标识符</h2>
<p>我们在 <a href="https://learnku.com/docs/effective-go/control-structure/6241#39e61d"><code>for-range</code> 循环</a>和<a href="https://learnku.com/docs/effective-go/data/6243#9da188">映射</a>中提过几次空白标识符。 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像 Unix 中的 <code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。 我们在前面已经见过它的用法了。</p>
<h3>多个参数赋值中的空白标识符</h3>
<p><code>for range</code> 循环中对空表标识符的用法是一种具体情况，更一般的情况即为多个参数赋值。</p>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf(<span class="hljs-string">"%s does not exist\n"</span>, path)
}
</span></span></foreignObject></svg></code></pre>
<p>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 很糟糕的代码！若路径不存在，它就会崩溃。</span>
fi, _ := os.Stat(path)
<span class="hljs-keyword">if</span> fi.IsDir() {
    fmt.Printf(<span class="hljs-string">"%s is a directory\n"</span>, path)
}
</span></span></foreignObject></svg></code></pre>
<h3>未使用的导入和变量</h3>
<p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的 Bug。 然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们， 但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。</p>
<p>这个写了一半的程序有两个未使用的导入（<code>fmt</code> 和 <code>io</code>）以及一个未使用的变量（<code>fd</code>），因此它不能编译， 但若到目前为止代码还是正确的，我们还是很乐意看到它们的。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"os"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fd, err := os.Open(<span class="hljs-string">"test.go"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> use fd.</span>
}
</span></span></foreignObject></svg></code></pre>
<p>要让编译器停止关于未使用导入的包，需要空白标识符来引用已导入包中的符号。 同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。 该程序的以下版本可以编译。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"os"</span>
)

<span class="hljs-keyword">var</span> _ = fmt.Printf  <span class="hljs-comment">// 用于调试，结束时删除。</span>
<span class="hljs-keyword">var</span> _ io.Reader    <span class="hljs-comment">// 用于调试，结束时删除。</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fd, err := os.Open(<span class="hljs-string">"test.go"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> use fd.</span>
    _ = fd
}
</span></span></foreignObject></svg></code></pre>
<p>按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到， 并作为以后清理它的提醒。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="104" data-paginate="true" data-theme="default" data-marpit-pagination="104" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>为辅助作用而导入</h3>
<p>像前例中 <code>fmt</code> 或 <code>io</code> 这种未使用的导入总应在最后被使用或移除： 空白赋值会将代码标识为工作正在进行中。但有时导入某个包只是为了其辅助作用， 而没有任何明确的使用。例如，在 <a href="https://golang.org/pkg/net/http/pprof/">net/http/pprof</a> 包的 <code>init</code> 函数中记录了 HTTP 处理程序的调试信息。它有个可导出的 API， 但大部分客户端只需要该处理程序的记录和通过 Web 页面访问数据。只为了其辅助作用来导入该包， 只需将包重命名为空白标识符：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">import</span> _ <span class="hljs-string">"net/http/pprof"</span>
</span></span></foreignObject></svg></code></pre>
<p>这种导入格式能明确表示该包是为其辅助作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="105" data-paginate="true" data-theme="default" data-marpit-pagination="105" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>接口检查</h3>
<p>就像我们在前面<a href="https://learnku.com/docs/effective-go/interface-and-other-types/6246">接口</a>中讨论的那样， 一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。 例如，将一个 <code>*os.File</code> 传入一个预期的 <code>io.Reader</code> 函数将不会被编译， 除非 <code>*os.File</code> 实现了 <code>io.Reader</code> 接口。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="106" data-paginate="true" data-theme="default" data-marpit-pagination="106" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>尽管有些接口检查会在运行时进行。<a href="https://golang.org/pkg/encoding/json/">encoding/json</a> 包中就有个实例它定义了一个 <a href="https://golang.org/pkg/encoding/json/#Marshaler">Marshaler</a> 接口。当 JSON 编码器接收到一个实现了该接口的值，那么该编码器就会调用该值的编组方法， 将其转换为 JSON，而非进行标准的类型转换。 编码器在运行时通过<a href="https://learnku.com/docs/effective-go/interface-and-other-types/6246#ea20df">类型断言</a>检查其属性，就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>m, ok := val.(json.Marshaler)
</span></span></foreignObject></svg></code></pre>
<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> _, ok := val.(json.Marshaler); ok {
    fmt.Printf(<span class="hljs-string">"value %v of type %T implements json.Marshaler\n"</span>, val, val)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="107" data-paginate="true" data-theme="default" data-marpit-pagination="107" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>当需要确保某个包中实现的类型一定满足该接口时，就会遇到这种情况。 若某个类型（例如 <a href="https://golang.org/pkg/encoding/json/#RawMessage">json.RawMessage</a>） 需要一种自定义的 JSON 表现时，它应当实现 <code>json.Marshaler</code>， 不过现在没有静态转换可以让编译器去自动验证它。若该类型通过忽略转换失败来满足该接口， 那么 JSON 编码器仍可工作，但它却不会使用自定义的实现。为确保其实现正确， 可在该包中用空白标识符声明一个全局变量：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="hljs-literal">nil</span>)
</span></span></foreignObject></svg></code></pre>
<p>在此声明中，我们调用了一个 <code>*RawMessage</code> 转换并将其赋予了 <code>Marshaler</code>，以此来要求 <code>*RawMessage</code> 实现 <code>Marshaler</code>，这时其属性就会在编译时被检测。 若 <code>json.Marshaler</code> 接口被更改，此包将无法通过编译， 而我们则会注意到它需要更新。</p>
<p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 只有当代码中不存在静态类型转换时才能使用这种声明，毕竟这是种非常罕见的情况。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="108" data-paginate="true" data-theme="default" data-marpit-pagination="108" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>内嵌</h2>
<p>Go 并不提供典型的，类型驱动的子类化概念，但通过将类型<strong>内嵌</strong>到结构体或接口中， 它就能 “借鉴” 部分实现。</p>
<p>接口内嵌非常简单。我们之前提到过 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，这里是它们的定义。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> {                       <span class="hljs-comment">//定义读取的接口类型</span>
    Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)       <span class="hljs-comment">//定义函数   传入[]byte类型  返回一个整型和err</span>
}

<span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> {                         <span class="hljs-comment">//定义写入的接口类型</span>
    Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)       <span class="hljs-comment">//定义函数   传入[]byte类型  返回一个整型和err</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="109" data-paginate="true" data-theme="default" data-marpit-pagination="109" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>io</code> 包也导出了一些其它接口，以此来阐明对象所需实现的方法。 例如 <code>io.ReadWriter</code> 就是个包含 <code>Read</code> 和 <code>Write</code> 的接口。我们可以通过显示地列出这两个方法来指明 <code>io.ReadWriter</code>， 但通过将这两个接口内嵌到新的接口中显然更容易且更具启发性，就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// ReadWriter 接口结合了 Reader 接口 和 Writer 接口</span>
<span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> {
    Reader
    Writer
}
</span></span></foreignObject></svg></code></pre>
<p>正如它看起来那样：<code>ReadWriter</code> 能够做任何 <code>Reader</code> <strong>和</strong> <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体 （它们必须是不相交的方法集）。只有接口能被嵌入到接口中。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="110" data-paginate="true" data-theme="default" data-marpit-pagination="110" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>同样的基本想法可以应用在结构体中，但其意义更加深远。<code>bufio</code> 包中有 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 这两个结构体类型， 它们每一个都实现了与 <code>io</code> 包中相同意义的接口。此外，<code>bufio</code> 还通过结合 <code>reader/writer</code> 并将其内嵌到结构体中，实现了带缓冲的 <code>reader/writer</code>：它列出了结构体中的类型，但并未给予它们字段名。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// ReadWriter 存储了指向 Reader 和 Writer 的指针。</span>
<span class="hljs-comment">// 它实现了 io.ReadWriter。</span>
<span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">struct</span> {
    *Reader  <span class="hljs-comment">// *bufio.Reader</span>
    *Writer  <span class="hljs-comment">// *bufio.Writer</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="111" data-paginate="true" data-theme="default" data-marpit-pagination="111" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>内嵌的元素为指向结构体的指针，当然它们在使用前必须被初始化为指向有效结构体的指针。 <code>ReadWriter</code> 结构体和通过如下方式定义：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">struct</span> {
    reader *Reader
    writer *Writer
}
</span></span></foreignObject></svg></code></pre>
<p>但为了提升该字段的方法并满足 <code>io</code> 接口，我们同样需要提供转发的方法， 就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *ReadWriter)</span> <span class="hljs-title">Read</span><span class="hljs-params">(p []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> {
    <span class="hljs-keyword">return</span> rw.reader.Read(p)
}
</span></span></foreignObject></svg></code></pre>
<p>而通过直接内嵌结构体，我们就能避免如此繁琐。 内嵌类型的方法可以直接引用，这意味着 <code>bufio.ReadWriter</code> 不仅包括 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的方法，它还同时满足下列三个接口： <code>io.Reader</code>、<code>io.Writer</code> 以及 <code>io.ReadWriter</code>。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="112" data-paginate="true" data-theme="default" data-marpit-pagination="112" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 <code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非 <code>ReadWriter</code> 本身。</p>
<p>内嵌同样可以提供便利。这个例子展示了一个内嵌字段和一个常规的命名字段。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Job <span class="hljs-keyword">struct</span> {
    Command <span class="hljs-keyword">string</span>
    *log.Logger
}
</span></span></foreignObject></svg></code></pre>
<p><code>Job</code> 类型现在有了 <code>Log</code>、<code>Logf</code> 和 <code>*log.Logger</code> 的其它方法。我们当然可以为 <code>Logger</code> 提供一个字段名，但完全不必这么做。现在，一旦初始化后，我们就能记录 <code>Job</code> 了：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>job.Println(<span class="hljs-string">"starting now..."</span>)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="113" data-paginate="true" data-theme="default" data-marpit-pagination="113" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>Logger</code> 是 <code>Job</code> 结构体的常规字段， 因此我们可在 <code>Job</code> 的构造函数中，通过一般的方式来初始化它，就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewJob</span><span class="hljs-params">(command <span class="hljs-keyword">string</span>, logger *log.Logger)</span> *<span class="hljs-title">Job</span></span> {
    <span class="hljs-keyword">return</span> &amp;Job{command, logger}
}
</span></span></foreignObject></svg></code></pre>
<p>或通过复合字面：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>job := &amp;Job{command, log.New(os.Stderr, <span class="hljs-string">"Job: "</span>, log.Ldate)}
</span></span></foreignObject></svg></code></pre>
<p>若我们需要直接引用内嵌字段，可以忽略包限定名，直接将该字段的类型名作为字段名， 就像我们在 <code>ReaderWriter</code> 结构体的 <code>Read</code> 方法中做的那样。 若我们需要访问 <code>Job</code> 类型的变量 <code>job</code> 的 <code>*log.Logger</code>， 可以直接写作 <code>job.Logger</code>。若我们想精炼 <code>Logger</code> 的方法时， 这会非常有用。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(job *Job)</span> <span class="hljs-title">Printf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>{})</span></span> {
    job.Logger.Printf(<span class="hljs-string">"%q: %s"</span>, job.Command, fmt.Sprintf(format, args...))
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="114" data-paginate="true" data-theme="default" data-marpit-pagination="114" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>内嵌类型会引入命名冲突的问题，但解决规则却很简单。首先，字段或方法 <code>X</code> 会隐藏该类型中更深层嵌套的其它项 <code>X</code>。若 <code>log.Logger</code> 包含一个名为 <code>Command</code> 的字段或方法，<code>Job</code> 的 <code>Command</code> 字段会覆盖它。</p>
<p>其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 <code>Job</code> 结构体中包含名为 <code>Logger</code> 的字段或方法，再将 <code>log.Logger</code> 内嵌到其中的话就会产生错误。然而，若重名永远不会在该类型定义之外的程序中使用，那就不会出错。 这种限定能够在外部嵌套类型发生修改时提供某种保护。 因此，就算添加的字段与另一个子类型中的字段相冲突，只要这两个相同的字段永远不会被使用就没问题。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="115" data-paginate="true" data-theme="default" data-marpit-pagination="115" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>并发</h2>
<h3>通过通信共享内存</h3>
<p>并发编程是个很大的论题。但限于篇幅，这里仅讨论一些 Go 特有的东西。</p>
<p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 Go 语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个 Go 协程能够访问该值。数据竞争从设计上就被杜绝了。 为了提倡这种思考方式，我们将它简化为一句口号：</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。 但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。</p>
<p>我们可以从典型的单线程运行在单 CPU 之上的情形来审视这种模型。它无需提供同步原语。 现在考虑另一种情况，它也无需同步。现在让它们俩进行通信。若将通信过程看做同步着， 那就完全不需要其它同步了。例如，Unix 管道就与这种模型完美契合。 尽管 Go 的并发处理方式来源于 Hoare 的通信顺序处理（CSP）， 它依然可以看做是类型安全的 Unix 管道的实现。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="116" data-paginate="true" data-theme="default" data-marpit-pagination="116" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>协程（goroutine）</h3>
<p>我们称之为 <strong>Go 协程</strong>是因为现有的术语 — 线程、协程、进程等等 — 无法准确传达它的含义。 Go 协程具有简单的模型：它是与其它 Go 协程并发运行在同一地址空间的函数。它是轻量级的， 所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p>
<p>Go 协程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I/O， 那么其它的线程就会运行。Go 协程的设计隐藏了线程创建和管理的诸多复杂性。</p>
<p>在函数或方法前添加 <code>go</code> 关键字能够在新的 Go 协程中调用它。当调用完成后， 该 Go 协程也会安静地退出。（效果有点像 Unix Shell 中的 <code>&amp;</code> 符号，它能让命令在后台运行。）</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">go</span> list.Sort()  <span class="hljs-comment">// 同时运行 list.Sort ; 不需要等待</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="117" data-paginate="true" data-theme="default" data-marpit-pagination="117" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>字面函数在协程中调用非常方便：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Announce</span><span class="hljs-params">(message <span class="hljs-keyword">string</span>, delay time.Duration)</span></span> {
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        time.Sleep(delay)
        fmt.Println(message)
    }()  <span class="hljs-comment">// 注意括号 - 必须调用函数</span>
}
</span></span></foreignObject></svg></code></pre>
<p>在 Go 中，字面函数都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。</p>
<p>这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="118" data-paginate="true" data-theme="default" data-marpit-pagination="118" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>信道</h3>
<p>信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>ci := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)            <span class="hljs-comment">// 整数无缓冲信道</span>
cj := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)         <span class="hljs-comment">// 整数无缓冲信道</span>
cs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *os.File, <span class="hljs-number">100</span>)  <span class="hljs-comment">// 指向文件的指针的缓冲信道</span>
</span></span></foreignObject></svg></code></pre>
<p>无缓冲信道在通信时会同步交换数据，它能确保（两个 Go 协程的）计算处于确定状态。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="119" data-paginate="true" data-theme="default" data-marpit-pagination="119" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>信道有很多惯用法，我们从这里开始了解。在上一节中，我们在后台启动了排序操作。 信道使得启动的 Go 协程等待排序完成。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)  <span class="hljs-comment">// 创建一个无缓冲的类型为整型的 channel 。</span>
<span class="hljs-comment">//用 goroutine 开始排序；当它完成时，会在信道上发信号。</span>
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
    list.Sort()
    c &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 发送一个信号，这个值并没有具体意义</span>
}()
doSomethingForAWhile()
&lt;-c   <span class="hljs-comment">// 等待 sort 执行完成，然后从 channel 取值</span>
</span></span></foreignObject></svg></code></pre>
<p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 <code>handle</code>，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量” 准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code> 的数量上限，因此我们在初始化时首先要填充至它的容量上限。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="120" data-paginate="true" data-theme="default" data-marpit-pagination="120" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, MaxOutstanding)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(r *Request)</span></span> {
    sem &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 等待活动队列清空。</span>
    process(r)  <span class="hljs-comment">// 可能需要很长时间。</span>
    &lt;-sem       <span class="hljs-comment">// 完成；使下一个请求可以运行。</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> {
        req := &lt;-queue
        <span class="hljs-keyword">go</span> handle(req)  <span class="hljs-comment">// 无需等待 handle 结束。</span>
    }
}
</span></span></foreignObject></svg></code></pre>
<p>一旦 <code>MaxOutstanding</code> 处理程序执行了 <code>process</code>，任何尝试发送到已占用的信道缓冲区的操作都会被屏蔽，直到至少一个程序完成并从缓冲区接收。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="121" data-paginate="true" data-theme="default" data-marpit-pagination="121" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>然而，它却有个设计问题：尽管只有 <code>MaxOutstanding</code> 个 Go 协程能同时运行，但 <code>Serve</code> 还是为每个进入的请求都创建了新的 Go 协程。其结果就是，若请求来得很快， 该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 <code>Serve</code> 来限制创建 Go 协程，这是个明显的解决方案，但要当心我们修复后出现的 Bug。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue {
        sem &lt;- <span class="hljs-number">1</span>
        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
            process(req) <span class="hljs-comment">// Buggy; see explanation below.</span>
            &lt;-sem
        }()
    }
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="122" data-paginate="true" data-theme="default" data-marpit-pagination="122" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>Bug 出现在 Go 的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此 <code>req</code> 变量会在所有的 Go 协程间共享，这不是我们想要的。我们需要确保 <code>req</code> 对于每个 Go 协程来说都是唯一的。有一种方法能够做到，就是将 <code>req</code> 的值作为实参传入到该 Go 协程的闭包中：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue {
        sem &lt;- <span class="hljs-number">1</span>
        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(req *Request)</span></span> {
            process(req)
            &lt;-sem
        }(req)
    }
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="123" data-paginate="true" data-theme="default" data-marpit-pagination="123" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>比较前后两个版本，观察该闭包声明和运行中的差别。 另一种解决方案就是以相同的名字创建新的变量，如例中所示：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue {
        req := req <span class="hljs-comment">// 为该Go协程创建 req 的新实例。</span>
        sem &lt;- <span class="hljs-number">1</span>
        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
            process(req)
            &lt;-sem
        }()
    }
}
</span></span></foreignObject></svg></code></pre>
<p>它的写法看起来有点奇怪</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>req := req
</span></span></foreignObject></svg></code></pre>
<p>但在 Go 中这样做是合法且常见的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个 Go 协程保持唯一。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="124" data-paginate="true" data-theme="default" data-marpit-pagination="124" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 <code>handle</code> Go 协程，一起从请求信道中读取数据。Go 协程的数量限制了同时调用 <code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道， 在启动所有 Go 协程后，它将阻塞并暂停从信道中接收消息。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> r := <span class="hljs-keyword">range</span> queue {
        process(r)
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(clientRequests <span class="hljs-keyword">chan</span> *Request, quit <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> {
    <span class="hljs-comment">// 启动处理程序</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; MaxOutstanding; i++ {
        <span class="hljs-keyword">go</span> handle(clientRequests)
    }
    &lt;-quit  <span class="hljs-comment">// 等待通知退出。</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="125" data-paginate="true" data-theme="default" data-marpit-pagination="125" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>信道中的信道</h3>
<p>Go 最重要的特性就是信道是一等值，它可以被分配并像其它值到处传递。 这种特性通常被用来实现安全、并行的多路分解。</p>
<p>在上一节的例子中，<code>handle</code> 是个非常理想化的请求处理程序， 但我们并未定义它所处理的请求类型。若该类型包含一个可用于回复的信道， 那么每一个客户端都能为其回应提供自己的路径。以下为 <code>Request</code> 类型的大概定义。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> {
    args        []<span class="hljs-keyword">int</span>
    f           <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>
    resultChan  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="126" data-paginate="true" data-theme="default" data-marpit-pagination="126" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>客户端提供了一个函数及其实参，此外在请求对象中还有个接收应答的信道。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(s <span class="hljs-keyword">int</span>)</span></span> {
    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a {
        s += v
    }
    <span class="hljs-keyword">return</span>
}

request := &amp;Request{[]<span class="hljs-keyword">int</span>{<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}, sum, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)}
<span class="hljs-comment">// 发送请求</span>
clientRequests &lt;- request
<span class="hljs-comment">// 等待回应</span>
fmt.Printf(<span class="hljs-string">"answer: %d\n"</span>, &lt;-request.resultChan)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="127" data-paginate="true" data-theme="default" data-marpit-pagination="127" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>服务端我们只修改 <code>handler</code> 函数：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> {
    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</span></span></foreignObject></svg></code></pre>
<p>要使其实际可用还有很多工作要做，这些代码仅能实现一个速率有限、并行、非阻塞 RPC 系统的 框架，而且它并不包含互斥锁。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="128" data-paginate="true" data-theme="default" data-marpit-pagination="128" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>并行化</h3>
<p>这些设计的另一个应用是在多 CPU 核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>
<p>让我们看看这个理想化的例子。我们在对一系列向量项进行极耗资源的操作， 而每个项的值计算是完全独立的。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> Vector []<span class="hljs-keyword">float64</span>

<span class="hljs-comment">// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span> <span class="hljs-title">DoSome</span><span class="hljs-params">(i, n <span class="hljs-keyword">int</span>, u Vector, c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> {
    <span class="hljs-keyword">for</span> ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// signal that this piece is done</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="129" data-paginate="true" data-theme="default" data-marpit-pagination="129" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>我们在循环中启动了独立的处理块，每个 CPU 将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有 Go 协程开始后接收，并统计信道中的完成信号即可。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">const</span> numCPU = <span class="hljs-number">4</span> <span class="hljs-comment">// CPU 核心数</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span> <span class="hljs-title">DoAll</span><span class="hljs-params">(u Vector)</span></span> {
    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, numCPU)  <span class="hljs-comment">// 缓冲区是可选的，但明显用上更好</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ {
        <span class="hljs-keyword">go</span> v.DoSome(i*<span class="hljs-built_in">len</span>(v)/numCPU, (i+<span class="hljs-number">1</span>)*<span class="hljs-built_in">len</span>(v)/numCPU, u, c)
    }
    <span class="hljs-comment">// 排空信道。</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ {
        &lt;-c    <span class="hljs-comment">// 等待任务完成</span>
    }
    <span class="hljs-comment">// 一切完成</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="130" data-paginate="true" data-theme="default" data-marpit-pagination="130" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>除了直接设置 <code>numCPU</code> 常量值以外，我们还可以向 runtime 询问一个合理的值。函数  <code>[runtime.NumCPU](https://golang.org/pkg/runtime#NumCPU)</code> 可以返回硬件 CPU 上的核心数量，如此使用：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> numCPU = runtime.NumCPU()
</span></span></foreignObject></svg></code></pre>
<p>另外一个需要知道的函数是 <a href="https://golang.org/pkg/runtime#GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a>，会返回用户设置可用 CPU 数量。默认情况下使用  <code>runtime.NumCPU</code> 的值，但是可以被命令行环境变量，或者调用此函数并传参正整数。传参 0 的话会返回值，假如说我们尊重用户对资源的分配，就应该这么写：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="hljs-number">0</span>)
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="131" data-paginate="true" data-theme="default" data-marpit-pagination="131" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>注意不要混淆并发（concurrency）和并行（parallelism）的概念：并发是用可独立执行组件构造程序的方法， 而并行则是为了效率在多 CPU 上平行地进行计算。<br />
尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go 仍然是种并发而非并行的语言，且 Go 的模型并不适合所有的并行问题。<br />
关于其中区别的讨论，见 <a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html">此博文</a>。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="132" data-paginate="true" data-theme="default" data-marpit-pagination="132" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>可能泄露的缓冲区</h3>
<p>并发编程的工具甚至能很容易地表达非并发的思想。这里有个提取自 RPC 包的例子。 客户端 Go 协程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过 <code>serverChan</code> 被发送到服务器。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> freeList = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer, <span class="hljs-number">100</span>)
<span class="hljs-keyword">var</span> serverChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">client</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">for</span> {
        <span class="hljs-keyword">var</span> b *Buffer
        <span class="hljs-comment">// 若缓冲区可用就用它，不可用就分配个新的。</span>
        <span class="hljs-keyword">select</span> {
        <span class="hljs-keyword">case</span> b = &lt;-freeList:
            <span class="hljs-comment">// 获取一个，不做别的。</span>
        <span class="hljs-keyword">default</span>:
            <span class="hljs-comment">// 非空闲，因此分配一个新的。</span>
            b = <span class="hljs-built_in">new</span>(Buffer)
        }
        load(b)              <span class="hljs-comment">// 从网络中读取下一条消息。</span>
        serverChan &lt;- b      <span class="hljs-comment">// 发送至服务器。</span>
    }
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="133" data-paginate="true" data-theme="default" data-marpit-pagination="133" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">for</span> {
        b := &lt;-serverChan    <span class="hljs-comment">// 等待工作。</span>
        process(b)
        <span class="hljs-comment">// 若缓冲区有空间就重用它。</span>
        <span class="hljs-keyword">select</span> {
        <span class="hljs-keyword">case</span> freeList &lt;- b:
            <span class="hljs-comment">// 将缓冲区放大空闲列表中，不做别的。</span>
        <span class="hljs-keyword">default</span>:
            <span class="hljs-comment">// 空闲列表已满，保持就好。</span>
        }
    }
}
</span></span></foreignObject></svg></code></pre>
<p>客户端试图从 <code>freeList</code> 中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将 <code>b</code> 放回空闲列表 <code>freeList</code> 中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（<code>select</code> 语句中的 <code>default</code> 子句在没有条件符合时执行，这也就意味着 <code>selects</code> 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="134" data-paginate="true" data-theme="default" data-marpit-pagination="134" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>错误</h2>
<p>库函数很多时候必须将错误信息返回给函数的调用者。如前所述，Go 允许函数可以有多个返回值的特性，使得函数的调用者在得到正常返回值的同时，可以获取到更为详细的错误信息。对库函数的设计者来说，一种推荐的做法是使用特性来提供详细的异常信息。 例如， <code>os.Open</code> 在异常时并不仅仅返回一个 <code>nil</code> 指针，它同时会返回一个错误值，用于描述是什么原因导致了异常的发生。</p>
<p>按照约定，错误的类型通常为 <code>error</code>，这是一个内置的简单接口。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> {
    Error() <span class="hljs-keyword">string</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="135" data-paginate="true" data-theme="default" data-marpit-pagination="135" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>库的开发者可以自由地用更丰富的模型实现这个接口，这样不仅可以看到错误，还可以提供一些上下文。如前所述，除了通常的 <code>*os.File</code> 返回值外，<code>os.Open</code> 还返回一个错误值。如果文件被成功打开，错误将为 <code>nil</code>，但是当出现问题时，它将返回一个 <code>os.PathError</code> 的错误，就像这样：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// PathError 记录错误、执行的操作和文件路径</span>
<span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> {
    Op <span class="hljs-keyword">string</span>    <span class="hljs-comment">// "open", "unlink" 等等对文件的操作</span>
    Path <span class="hljs-keyword">string</span>  <span class="hljs-comment">// 相关文件的路径</span>
    Err error    <span class="hljs-comment">// 由系统调用返回</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">" "</span> + e.Path + <span class="hljs-string">": "</span> + e.Err.Error()
}
</span></span></foreignObject></svg></code></pre>
<p><code>PathError</code> 的 <code>Error</code> 会生成如下错误信息：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap>open /etc/passwx: no such file or directory
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="136" data-paginate="true" data-theme="default" data-marpit-pagination="136" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这种错误包含了出错的文件名、操作和触发的操作系统错误。可见即便输出错误信息时已经远离导致错误的调用，它也会非常有用，这比简单的 “不存在该文件或目录” 包含的信息丰富得多。</p>
<p>错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。例如在 <code>image</code> 包中，由于未知格式导致解码错误的字符串为 <code>image: unknown format</code>（未知的格式）。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="137" data-paginate="true" data-theme="default" data-marpit-pagination="137" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。比如 <code>PathErrors</code>，它你可能会想检查内部的 <code>Err</code> 字段来判断这是否是一个可以被恢复的错误。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; <span class="hljs-number">2</span>; try++ {
    file, err = os.Create(filename)
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  <span class="hljs-comment">// 恢复一些空间。</span>
        <span class="hljs-keyword">continue</span>
    }
    <span class="hljs-keyword">return</span>
}
</span></span></foreignObject></svg></code></pre>
<p>这里的第二条 <code>if</code> 是另一种方式，称为 <a href="https://learnku.com/docs/effective-go/interface-and-other-types/6246#2617cf">类型断言</a>。若它失败， <code>ok</code> 将为 <code>false</code>，而 <code>e</code> 则为 <code>nil</code>. 若它成功，<code>ok</code> 将为 <code>true</code>。类型断言若成功，则该错误必然属于 <code>*os.PathError</code> 类型，而 <code>e</code> 能够检测关于该错误的更多信息。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="138" data-paginate="true" data-theme="default" data-marpit-pagination="138" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>Panic</h3>
<p>向调用者报告错误的一般方式就是将 <code>error</code> 作为额外的值返回。 标准的 <code>Read</code> 方法就是个众所周知的实例，它返回一个字节计数和一个 <code>error</code>。但如果错误时不可恢复的呢？有时程序就是不能继续运行。</p>
<p>为此，我们提供了内建的 <code>panic</code> 函数，它会产生一个运行时错误并终止程序 （但请继续看下一节）。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="139" data-paginate="true" data-theme="default" data-marpit-pagination="139" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// 用牛顿法计算立方根的一个玩具实现。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CubeRoot</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> {
    z := x/<span class="hljs-number">3</span>   <span class="hljs-comment">// Arbitrary initial value</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e6</span>; i++ {
        prevz := z
        z -= (z*z*z-x) / (<span class="hljs-number">3</span>*z*z)
        <span class="hljs-keyword">if</span> veryClose(z, prevz) {
            <span class="hljs-keyword">return</span> z
        }
    }
    <span class="hljs-comment">// 一百万次迭代并未收敛，事情出错了。</span>
    <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"CubeRoot(%g) did not converge"</span>, x))
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="140" data-paginate="true" data-theme="default" data-marpit-pagination="140" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>这仅仅是个示例，真正的库函数应避免 <code>panic</code>。若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序。一个可能的反例就是初始化：若某个库真的不能让自己工作，且有足够理由产生 Panic，那就由它去吧。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">var</span> user = os.Getenv(<span class="hljs-string">"USER"</span>)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> user == <span class="hljs-string">""</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"no value for $USER"</span>)
    }
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="141" data-paginate="true" data-theme="default" data-marpit-pagination="141" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h3>recover</h3>
<p>当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片越界访问或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯 Go 协程的栈，运行任何被推迟的函数。 若回溯到达 Go 协程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code> 函数来重新或来取回 Go 协程的控制权限并使其恢复正常执行。</p>
<p>调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code> 只能在被推迟的函数中才有效。</p>
<p><code>recover</code> 的一个应用就是在服务器中终止失败的 Go 协程而无需杀死其它正在执行的 Go 协程。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="142" data-paginate="true" data-theme="default" data-marpit-pagination="142" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(workChan &lt;-<span class="hljs-keyword">chan</span> *Work)</span></span> {
    <span class="hljs-keyword">for</span> work := <span class="hljs-keyword">range</span> workChan {
        <span class="hljs-keyword">go</span> safelyDo(work)
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">safelyDo</span><span class="hljs-params">(work *Work)</span></span> {
    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> {
            log.Println(<span class="hljs-string">"work failed:"</span>, err)
        }
    }()
    do(work)
}
</span></span></foreignObject></svg></code></pre>
<p>在此例中，若 <code>do(work)</code> 触发了 Panic，其结果就会被记录， 而该 Go 协程会被干净利落地结束，不会干扰到其它 Go 协程。我们无需在推迟的闭包中做任何事情， <code>recover</code> 会处理好这一切。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="143" data-paginate="true" data-theme="default" data-marpit-pagination="143" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>由于直接从被推迟函数中调用 <code>recover</code> 时不会返回 <code>nil</code>， 因此被推迟的代码能够调用本身使用了 <code>panic</code> 和 <code>recover</code> 的库函数而不会失败。例如在 <code>safelyDo</code> 中，被推迟的函数可能在调用 <code>recover</code> 前先调用记录函数，而该记录函数应当不受 Panic 状态的代码的影响。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="144" data-paginate="true" data-theme="default" data-marpit-pagination="144" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>通过恰当地使用恢复模式，<code>do</code> 函数（及其调用的任何代码）可通过调用 <code>panic</code> 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。 让我们看看 <code>regexp</code> 包的理想化版本，它会以局部的错误类型调用 <code>panic</code> 来报告解析错误。以下是一个 <code>error</code> 类型的 <code>Error</code> 方法和一个 <code>Compile</code> 函数的定义：</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="145" data-paginate="true" data-theme="default" data-marpit-pagination="145" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-comment">// Error 是解析错误的类型，它满足 error 接口。</span>
<span class="hljs-keyword">type</span> Error <span class="hljs-keyword">string</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Error)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(e)
}

<span class="hljs-comment">// error 是 *Regexp 的方法，它通过用一个 Error </span>
<span class="hljs-comment">// 触发Panic来报告解析错误。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(regexp *Regexp)</span> <span class="hljs-title">error</span><span class="hljs-params">(err <span class="hljs-keyword">string</span>)</span></span> {
    <span class="hljs-built_in">panic</span>(Error(err))
}

<span class="hljs-comment">// Compile 返回该正则表达式解析后的表示。</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compile</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(regexp *Regexp, err error)</span></span> {
    regexp = <span class="hljs-built_in">new</span>(Regexp)
    <span class="hljs-comment">// 当发生解析错误时，doParse 会触发 panic</span>
    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> e := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span> {
            regexp = <span class="hljs-literal">nil</span>    <span class="hljs-comment">// 清理返回值。</span>
            err = e.(Error) <span class="hljs-comment">// 若它不是解析错误，将重新触发Panic。</span>
        }
    }()
    <span class="hljs-keyword">return</span> regexp.doParse(str), <span class="hljs-literal">nil</span>
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="146" data-paginate="true" data-theme="default" data-marpit-pagination="146" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>若 <code>doParse</code> 触发了 Panic，恢复块会将返回值设为 <code>nil</code> — 被推迟的函数能够修改已命名的返回值。在 <code>err</code> 的赋值过程中， 我们将通过断言它是否拥有局部类型 <code>Error</code> 来检查它。若它没有， 类型断言将会失败，此时会产生运行时错误，并继续栈的回溯，仿佛一切从未中断过一样。 该检查意味着若发生了一些像索引越界之类的意外，那么即便我们使用了 <code>panic</code> 和 <code>recover</code> 来处理解析错误，代码仍然会失败。</p>
<p>通过适当的错误处理，<code>error</code> 方法（由于它是个绑定到具体类型的方法， 因此即便它与内建的 <code>error</code> 类型名字相同也没有关系） 能让报告解析错误变得更容易，而无需手动处理回溯的解析栈：</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">if</span> pos == <span class="hljs-number">0</span> {
    re.error(<span class="hljs-string">"'*' illegal at start of expression"</span>)
}
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="147" data-paginate="true" data-theme="default" data-marpit-pagination="147" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>尽管这种模式很有用，但它应当仅在包内使用。<code>Parse</code> 会将其内部的 <code>panic</code> 调用转为 <code>error</code> 值，它并不会向调用者暴露出 <code>panic</code>。这是个值得遵守的良好规则。</p>
<p>顺便一提，这种重新触发 Panic 的惯用法会在产生实际错误时改变 Panic 的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发 Panic 的模型已经够用了，毕竟他只是一次崩溃。 但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发 Panic。 这里就将这个练习留给读者了。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="148" data-paginate="true" data-theme="default" data-marpit-pagination="148" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<h2>示例：Web 服务器</h2>
<p>让我们以一个完整的 Go 程序作为结束吧，一个 Web 服务器。该程序其实只是个 Web 服务器的重用。 Google 在 <a href="http://chart.apis.google.com/">chart.apis.google.com</a> 上提供了一个将表单数据自动转换为图表的服务。不过，该服务很难交互， 因为你需要将数据作为查询放到 URL 中。此程序为一种数据格式提供了更好的的接口： 给定一小段文本，它将调用图表服务器来生成二维码（QR 码），这是一种编码文本的点格矩阵。 该图像可被你的手机摄像头捕获，并解释为一个字符串，比如 URL， 这样就免去了你在狭小的手机键盘上键入 URL 的麻烦。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="149" data-paginate="true" data-theme="default" data-marpit-pagination="149" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>以下为完整的程序，随后有一段解释。</p>
<pre><code class="language-go"><svg data-marp-fitting="svg" data-marp-fitting-code><foreignObject><span data-marp-fitting-svg-content><span data-marp-fitting-svg-content-wrap><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"flag"</span>
    <span class="hljs-string">"html/template"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"net/http"</span>
)

<span class="hljs-keyword">var</span> addr = flag.String(<span class="hljs-string">"addr"</span>, <span class="hljs-string">":1718"</span>, <span class="hljs-string">"http service address"</span>) <span class="hljs-comment">// Q=17, R=18</span>

<span class="hljs-keyword">var</span> templ = template.Must(template.New(<span class="hljs-string">"qr"</span>).Parse(templateStr))

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    flag.Parse()
    http.Handle(<span class="hljs-string">"/"</span>, http.HandlerFunc(QR))
    err := http.ListenAndServe(*addr, <span class="hljs-literal">nil</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(<span class="hljs-string">"ListenAndServe:"</span>, err)
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QR</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {
    templ.Execute(w, req.FormValue(<span class="hljs-string">"s"</span>))
}

<span class="hljs-keyword">const</span> templateStr = <span class="hljs-string">`
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;QR Link Generator&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{if .}}
&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}" /&gt;
&lt;br&gt;
{{.}}
&lt;br&gt;
&lt;br&gt;
{{end}}
&lt;form action="/" name=f method="GET"&gt;&lt;input maxLength=1024 size=70
name=s value="" title="Text to QR Encode"&gt;&lt;input type=submit
value="Show QR" name=qr&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
`</span>
</span></span></foreignObject></svg></code></pre>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="150" data-paginate="true" data-theme="default" data-marpit-pagination="150" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p><code>main</code> 之前的代码应该比较容易理解。我们通过一个标志为服务器设置了默认端口。 模板变量 <code>templ</code> 正式有趣的地方。它构建的 HTML 模版将会被服务器执行并显示在页面中。 稍后我们将详细讨论。</p>
<p><code>main</code> 函数解析了参数标志并使用我们讨论过的机制将 <code>QR</code> 函数绑定到服务器的根路径。然后调用 <code>http.ListenAndServe</code> 启动服务器；它将在服务器运行时处于阻塞状态。</p>
<p><code>QR</code> 仅接受包含表单数据的请求，并为表单值 <code>s</code> 中的数据执行模板。</p>
<p>模板包 <code>html/template</code> 非常强大；该程序只是浅尝辄止。 本质上，它通过在运行时将数据项中提取的元素（在这里是表单值）传给 <code>templ.Execute</code> 执行因而重写了 HTML 文本。 在模板文本（<code>templateStr</code>）中，双大括号界定的文本表示模板的动作。 从 <code>{{if .}}</code> 到 <code>{{end}}</code> 的代码段仅在当前数据项（这里是点 <code>.</code>）的值非空时才会执行。 也就是说，当字符串为空时，此部分模板段会被忽略。</p>
</section>
</foreignObject></svg><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="151" data-paginate="true" data-theme="default" data-marpit-pagination="151" data-marpit-pagination-total="151" style="--paginate:true;--theme:default;">
<p>其中两段 <code>{{.}}</code> 表示要将数据显示在模板中 （即将查询字符串显示在 Web 页面上）。HTML 模板包将自动对文本进行转义， 因此文本的显示是安全的。</p>
<p>余下的模板字符串只是页面加载时将要显示的 HTML。如果这段解释你无法理解，请参考 <a href="https://go-zh.org/pkg/html/template/">文档</a> 获得更多有关模板包的解释。</p>
<p>你终于如愿以偿了：以几行代码实现的，包含一些数据驱动的 HTML 文本的 Web 服务器。 Go 语言强大到能让很多事情以短小精悍的方式解决。</p>
</section>
<script>!function(){"use strict";function t(t){Array.from(document.getElementsByTagName("svg"),e=>{if(e.hasAttribute("data-marpit-svg")){const{clientHeight:r,clientWidth:a}=e;e.style.transform||(e.style.transform="translateZ(0)");const o=t||e.currentScale||1,i=e.viewBox.baseVal.width/o,n=e.viewBox.baseVal.height/o,s=Math.min(r/n,a/i);Array.from(e.querySelectorAll(":scope > foreignObject"),t=>{const e=t.x.baseVal.value,o=t.y.baseVal.value;Array.from(t.querySelectorAll(":scope > section"),t=>{t.style.transformOrigin||(t.style.transformOrigin="0 0");const l=(a-s*i)/2-e,c=(r-s*n)/2-o;t.style.transform=`translate3d(${l}px,${c}px,0) scale(${s}) translate(${e}px,${o}px)`})})}})}const e=(t,e,r)=>{if(t.getAttribute(e)!==r)return t.setAttribute(e,r),!0};function r(a=!0){for(const e of"Apple Computer, Inc."===navigator.vendor?[t]:[])e();Array.from(document.querySelectorAll('svg[data-marp-fitting="svg"]'),t=>{const r=t.firstChild,a=r.firstChild,{scrollWidth:o,scrollHeight:i}=a;let n,s=1;if(t.hasAttribute("data-marp-fitting-code")&&(n=t.parentElement.parentElement),t.hasAttribute("data-marp-fitting-math")&&(n=t.parentElement),n){const t=getComputedStyle(n),e=Math.ceil(n.clientWidth-parseFloat(t.paddingLeft)-parseFloat(t.paddingRight));e&&(s=e)}const l=Math.max(o,s),c=Math.max(i,1),p=`0 0 ${l} ${c}`;e(r,"width",""+l),e(r,"height",""+c),e(t,"preserveAspectRatio",getComputedStyle(t).getPropertyValue("--preserve-aspect-ratio")||"xMinYMin meet"),e(t,"viewBox",p)&&t.classList.toggle("__reflow__")}),a&&window.requestAnimationFrame(()=>r(a))}!function(){if("undefined"==typeof window)throw new Error("Marp Core's browser script is valid only in browser context.");window.marpCoreBrowserScript?console.warn("Marp Core's browser script has already executed."):(Object.defineProperty(window,"marpCoreBrowserScript",{value:!0}),r())}()}();
</script></foreignObject></svg></div><script>!function(){"use strict";var e=function(e,t){var n,r=1===(e.parent||e).nodeType?e.parent||e:document.querySelector(e.parent||e),s=[].filter.call("string"==typeof e.slides?r.querySelectorAll(e.slides):e.slides||r.children,(function(e){return"SCRIPT"!==e.nodeName})),a={},o=function(e,t){return(t=t||{}).index=s.indexOf(e),t.slide=e,t},i=function(e,t){a[e]=(a[e]||[]).filter((function(e){return e!==t}))},l=function(e,t){return(a[e]||[]).reduce((function(e,n){return e&&!1!==n(t)}),!0)},c=function(e,t){s[e]&&(n&&l("deactivate",o(n,t)),n=s[e],l("activate",o(n,t)))},d=function(e,t){var r=s.indexOf(n)+e;l(e>0?"next":"prev",o(n,t))&&c(r,t)},u={off:i,on:function(e,t){return(a[e]||(a[e]=[])).push(t),i.bind(null,e,t)},fire:l,slide:function(e,t){if(!arguments.length)return s.indexOf(n);l("slide",o(s[e],t))&&c(e,t)},next:d.bind(null,1),prev:d.bind(null,-1),parent:r,slides:s,destroy:function(e){l("destroy",o(n,e)),a={}}};return(t||[]).forEach((function(e){e(u)})),n||c(0),u};function t(e){e.parent.classList.add("bespoke-marp-parent"),e.slides.map(e=>e.classList.add("bespoke-marp-slide")),e.on("activate",t=>{e.slides.map(e=>e.classList.remove("bespoke-marp-active")),t.slide.classList.add("bespoke-marp-active")})}function n(e=2e3){return t=>{let n;function r(){n&&clearTimeout(n),n=setTimeout(()=>{t.parent.classList.add("bespoke-marp-inactive")},e),t.parent.classList.remove("bespoke-marp-inactive")}document.addEventListener("mousedown",r),document.addEventListener("mousemove",r),document.addEventListener("touchend",r),setTimeout(r,0)}}const r=["AUDIO","BUTTON","INPUT","SELECT","TEXTAREA","VIDEO"];function s(e){e.parent.addEventListener("keydown",e=>{if(!e.target)return;const t=e.target;(r.includes(t.nodeName)||"true"===t.contentEditable)&&e.stopPropagation()})}function a(e){window.addEventListener("load",()=>{for(const t of e.slides){const e=t.querySelector("[data-marp-fitting]")?"":"hideable";t.setAttribute("data-bespoke-marp-load",e)}})}function o(e){let t=0,n=0;Object.defineProperty(e,"fragments",{enumerable:!0,value:e.slides.map(e=>[null,...e.querySelectorAll("[data-marpit-fragment]")])});const r=r=>void 0!==e.fragments[t][n+r],s=(r,s)=>{t=r,n=s,e.fragments.forEach((e,t)=>{e.forEach((e,n)=>{if(null==e)return;const a=t<r||t===r&&n<=s;e.setAttribute("data-bespoke-marp-fragment",a?"active":"inactive"),t===r&&n===s?e.setAttribute("data-bespoke-marp-current-fragment","current"):e.removeAttribute("data-bespoke-marp-current-fragment")})}),e.fragmentIndex=s;const a={slide:e.slides[r],index:r,fragments:e.fragments[r],fragmentIndex:s};e.fire("fragment",a)};e.on("next",()=>{if(r(1))return s(t,n+1),!1;const a=t+1;e.fragments[a]&&s(a,0)}),e.on("prev",()=>{if(r(-1))return s(t,n-1),!1;const a=t-1;e.fragments[a]&&s(a,e.fragments[a].length-1)}),e.on("slide",({index:t,fragment:n})=>{let r=0;if(void 0!==n){const s=e.fragments[t];if(s){const{length:e}=s;r=-1===n?e-1:Math.min(Math.max(n,0),e-1)}}s(t,r)}),s(0,0)}var i,l=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e){
/*!
  * screenfull
  * v5.0.2 - 2020-02-13
  * (c) Sindre Sorhus; MIT License
  */
!function(){var t="undefined"!=typeof window&&void 0!==window.document?window.document:{},n=e.exports,r=function(){for(var e,n=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","webkitCancelFullScreen","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"],["msRequestFullscreen","msExitFullscreen","msFullscreenElement","msFullscreenEnabled","MSFullscreenChange","MSFullscreenError"]],r=0,s=n.length,a={};r<s;r++)if((e=n[r])&&e[1]in t){for(r=0;r<e.length;r++)a[n[0][r]]=e[r];return a}return!1}(),s={change:r.fullscreenchange,error:r.fullscreenerror},a={request:function(e){return new Promise(function(n,s){var a=function(){this.off("change",a),n()}.bind(this);this.on("change",a);var o=(e=e||t.documentElement)[r.requestFullscreen]();o instanceof Promise&&o.then(a).catch(s)}.bind(this))},exit:function(){return new Promise(function(e,n){if(this.isFullscreen){var s=function(){this.off("change",s),e()}.bind(this);this.on("change",s);var a=t[r.exitFullscreen]();a instanceof Promise&&a.then(s).catch(n)}else e()}.bind(this))},toggle:function(e){return this.isFullscreen?this.exit():this.request(e)},onchange:function(e){this.on("change",e)},onerror:function(e){this.on("error",e)},on:function(e,n){var r=s[e];r&&t.addEventListener(r,n,!1)},off:function(e,n){var r=s[e];r&&t.removeEventListener(r,n,!1)},raw:r};r?(Object.defineProperties(a,{isFullscreen:{get:function(){return Boolean(t[r.fullscreenElement])}},element:{enumerable:!0,get:function(){return t[r.fullscreenElement]}},isEnabled:{enumerable:!0,get:function(){return Boolean(t[r.fullscreenEnabled])}}}),n?e.exports=a:window.screenfull=a):n?e.exports={isEnabled:!1}:window.screenfull={isEnabled:!1}}()}));l.isEnabled;function c(e){e.fullscreen=()=>{l.isEnabled&&l.toggle(document.body)},document.addEventListener("keydown",t=>{70!==t.which&&122!==t.which||t.altKey||t.ctrlKey||t.metaKey||!l.isEnabled||(e.fullscreen(),t.preventDefault())})}function d(e={}){const t=Object.assign({interval:200},e);return e=>{document.addEventListener("keydown",t=>{(32===t.which&&t.shiftKey||33===t.which||37===t.which||38===t.which)&&e.prev(),(32===t.which&&!t.shiftKey||34===t.which||39===t.which||40===t.which)&&e.next(),35===t.which&&e.slide(e.slides.length-1,{fragment:-1}),36===t.which&&e.slide(0)});let n,r,s=0;e.parent.addEventListener("wheel",a=>{let o=!1;const l=(e,t)=>{e&&(o=o||function(e,t){return function(e,t){const n=t===i.X?"Width":"Height";return e["client"+n]<e["scroll"+n]}(e,t)&&function(e,t){const{overflow:n}=e,r=e["overflow"+t];return"auto"===n||"scroll"===n||"auto"===r||"scroll"===r}(getComputedStyle(e),t)}(e,t)),(null==e?void 0:e.parentElement)&&l(e.parentElement,t)};if(0!==a.deltaX&&l(a.target,i.X),0!==a.deltaY&&l(a.target,i.Y),o)return;a.preventDefault(),r&&clearTimeout(r),r=setTimeout(()=>{n=0},t.interval);const c=Date.now()-s<t.interval,d=Math.sqrt(Math.pow(a.deltaX,2)+Math.pow(a.deltaY,2)),u=d<=n;if(n=d,c||u)return;let f;(a.deltaX>0||a.deltaY>0)&&(f="next"),(a.deltaX<0||a.deltaY<0)&&(f="prev"),f&&(e[f](),s=Date.now())})}}!function(e){e.X="X",e.Y="Y"}(i||(i={}));const u=(...e)=>history.replaceState(...e);var f;!function(e){e.Normal="",e.Presenter="presenter",e.Next="next"}(f||(f={}));const p=(e,{protocol:t,host:n,pathname:r,hash:s}=location)=>{const a=e.toString();return`${t}//${n}${r}${a?"?":""}${a}${s}`},m=()=>{switch(document.body.getAttribute("data-bespoke-view")){case f.Normal:return f.Normal;case f.Presenter:return f.Presenter;case f.Next:return f.Next;default:throw new Error("View mode is not assigned.")}},h=e=>new URLSearchParams(location.search).get(e),g=(e,t={})=>{const n=Object.assign({location:location,setter:u},t),r=new URLSearchParams(n.location.search);for(const t of Object.keys(e)){const n=e[t];"string"==typeof n?r.set(t,n):r.delete(t)}try{n.setter(null,document.title,p(r,n.location))}catch(e){console.error(e)}},b={available:(()=>{try{return localStorage.setItem("bespoke-marp","bespoke-marp"),localStorage.removeItem("bespoke-marp"),!0}catch(e){return console.warn("Warning: Using localStorage is restricted in the current host so some features may not work."),!1}})(),get:e=>{try{return localStorage.getItem(e)}catch(e){return null}},set:(e,t)=>{try{return localStorage.setItem(e,t),!0}catch(e){return!1}},remove:e=>{try{return localStorage.removeItem(e),!0}catch(e){return!1}}};function v(e=".bespoke-marp-osc"){const t=document.querySelector(e);if(!t)return()=>{};const n=(e,n)=>{t.querySelectorAll(`[data-bespoke-marp-osc=${JSON.stringify(e)}]`).forEach(n)};return l.isEnabled||n("fullscreen",e=>e.style.display="none"),b.available||n("presenter",e=>{e.disabled=!0,e.title="Presenter view is disabled due to restricted localStorage."}),e=>{t.addEventListener("click",t=>{if(t.target instanceof HTMLElement){const{bespokeMarpOsc:n}=t.target.dataset;switch(n&&t.target.blur(),n){case"next":e.next();break;case"prev":e.prev();break;case"fullscreen":"function"==typeof e.fullscreen&&l.isEnabled&&e.fullscreen();break;case"presenter":e.openPresenterView()}}}),e.parent.appendChild(t),e.on("activate",({index:t})=>{n("page",n=>n.textContent=`Page ${t+1} of ${e.slides.length}`)}),e.on("fragment",({index:t,fragments:r,fragmentIndex:s})=>{n("prev",e=>e.disabled=0===t&&0===s),n("next",n=>n.disabled=t===e.slides.length-1&&s===r.length-1)}),l.isEnabled&&l.onchange(()=>n("fullscreen",e=>e.classList.toggle("exit",l.isEnabled&&l.isFullscreen)))}}function w(){const e=Math.max(Math.floor(.85*window.innerWidth),640),t=Math.max(Math.floor(.85*window.innerHeight),360);return window.open(this.presenterUrl,"bespoke-marp-presenter-"+this.syncKey,`width=${e},height=${t},menubar=no,toolbar=no`)}function y(){const e=new URLSearchParams(location.search);return e.set("view","presenter"),e.set("sync",this.syncKey),p(e)}var x=["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];let E=e=>String(e).replace(/[&<>"']/g,e=>`&${k[e]};`),k={"&":"amp","<":"lt",">":"gt",'"':"quot","'":"apos"},S="dangerouslySetInnerHTML",L={className:"class",htmlFor:"for"},I={};function P(e,t){let n=[],r="";t=t||{};for(let e=arguments.length;e-- >2;)n.push(arguments[e]);if("function"==typeof e)return t.children=n.reverse(),e(t);if(e){if(r+="<"+e,t)for(let e in t)!1!==t[e]&&null!=t[e]&&e!==S&&(r+=` ${L[e]?L[e]:E(e)}="${E(t[e])}"`);r+=">"}if(-1===x.indexOf(e)){if(t[S])r+=t[S].__html;else for(;n.length;){let e=n.pop();if(e)if(e.pop)for(let t=e.length;t--;)n.push(e[t]);else r+=!0===I[e]?e:E(e)}r+=e?`</${e}>`:""}return I[r]=!0,r}const M=({children:e})=>P(null,null,...e),N="bespoke-marp-presenter-container",F="bespoke-marp-presenter-next",O="bespoke-marp-presenter-next-container",T="bespoke-marp-presenter-note-container",q="bespoke-marp-presenter-info-container",C="bespoke-marp-presenter-info-page",$="bespoke-marp-presenter-info-page-text",j="bespoke-marp-presenter-info-page-prev",A="bespoke-marp-presenter-info-page-next",K="bespoke-marp-presenter-info-time",R="bespoke-marp-presenter-info-timer";function U(e){const{title:t}=document;document.title="[Presenter view]"+(t?" - "+t:"");const n={},r=e=>(n[e]=n[e]||document.querySelector("."+e),n[e]);document.body.appendChild((e=>{const t=document.createElement("div");return t.className=N,t.appendChild(e),t.insertAdjacentHTML("beforeend",P(M,null,P("div",{class:O},P("iframe",{class:F,src:"?view=next"})),P("div",{class:T}),P("div",{class:q},P("div",{class:C},P("button",{class:j,tabindex:"-1",title:"Previous"},"Previous"),P("span",{class:$}),P("button",{class:A,tabindex:"-1",title:"Next"},"Next")),P("time",{class:K,title:"Current time"}),P("div",{class:R})))),t})(e.parent)),(e=>{r(O).addEventListener("click",()=>e.next());const t=r(F),n=(s=t,(e,t)=>s.contentWindow.postMessage(`navigate:${e},${t}`,"null"===window.origin?"*":window.origin));var s;t.addEventListener("load",()=>{r(O).classList.add("active"),n(e.slide(),e.fragmentIndex),e.on("fragment",({index:e,fragmentIndex:t})=>n(e,t))});const a=document.querySelectorAll(".bespoke-marp-note");a.forEach(e=>{e.addEventListener("keydown",e=>e.stopPropagation()),r(T).appendChild(e)}),e.on("activate",()=>a.forEach(t=>t.classList.toggle("active",t.dataset.index==e.slide()))),e.on("activate",({index:t})=>{r($).textContent=`${t+1} / ${e.slides.length}`});const o=r(j),i=r(A);o.addEventListener("click",()=>{o.blur(),e.prev()}),i.addEventListener("click",()=>{i.blur(),e.next()}),e.on("fragment",({index:t,fragments:n,fragmentIndex:r})=>{o.disabled=0===t&&0===r,i.disabled=t===e.slides.length-1&&r===n.length-1});const l=()=>r(K).textContent=(new Date).toLocaleTimeString();l(),setInterval(l,250)})(e)}function V(e){const t=m();return t===f.Next&&e.appendChild(document.createElement("span")),e=>{t===f.Normal&&function(e){if(!(e=>e.syncKey&&"string"==typeof e.syncKey)(e))throw new Error("The current instance of Bespoke.js is invalid for Marp bespoke presenter plugin.");Object.defineProperties(e,{openPresenterView:{enumerable:!0,value:w},presenterUrl:{enumerable:!0,get:y}}),b.available&&document.addEventListener("keydown",t=>{80!==t.which||t.altKey||t.ctrlKey||t.metaKey||(t.preventDefault(),e.openPresenterView())})}(e),t===f.Presenter&&U(e),t===f.Next&&function(e){const t=t=>{if(t.origin!==window.origin)return;const[n,r]=t.data.split(":");if("navigate"===n){const[t,n]=r.split(",");e.slide(Number.parseInt(t,10),{fragment:Number.parseInt(n,10)}),e.next()}};window.addEventListener("message",t),e.on("destroy",()=>window.removeEventListener("message",t))}(e)}}function X(e){e.on("activate",t=>{document.querySelectorAll(".bespoke-progress-bar").forEach(n=>{n.style.flexBasis=100*t.index/(e.slides.length-1)+"%"})})}const D=e=>{const t=Number.parseInt(e,10);return Number.isNaN(t)?null:t};function Y(e={}){const t=Object.assign({history:!0},e);return e=>{let n=!0;const r=e=>{const t=n;try{return n=!0,e()}finally{n=t}},s=(t={fragment:!0})=>{((t,n)=>{const{fragments:r,slides:s}=e,a=Math.max(0,Math.min(t,s.length-1)),o=Math.max(0,Math.min(n||0,r[a].length-1));a===e.slide()&&o===e.fragmentIndex||e.slide(a,{fragment:o})})((D(location.hash.slice(1))||1)-1,t.fragment?D(h("f")||""):null)};e.on("fragment",({index:e,fragmentIndex:r})=>{n||g({f:0===r||r.toString()},{location:Object.assign(Object.assign({},location),{hash:"#"+(e+1)}),setter:(...e)=>t.history?history.pushState(...e):history.replaceState(...e)})}),setTimeout(()=>{s(),window.addEventListener("hashchange",()=>r(()=>{s({fragment:!1}),g({f:void 0})})),window.addEventListener("popstate",()=>{n||r(()=>s())}),n=!1},0)}}function B(e={}){const t=e.key||((e=21)=>{let t="",n=crypto.getRandomValues(new Uint8Array(e));for(;e--;){let r=63&n[e];t+=r<36?r.toString(36):r<62?(r-26).toString(36).toUpperCase():r<63?"_":"-"}return t})(),n="bespoke-marp-sync-"+t,r=()=>{const e=b.get(n);return e?JSON.parse(e):Object.create(null)},s=e=>{const t=r(),s=Object.assign(Object.assign({},t),e(t));return b.set(n,JSON.stringify(s)),s};return s(e=>({reference:(e.reference||0)+1})),e=>{Object.defineProperty(e,"syncKey",{value:t,enumerable:!0});let a=!0;setTimeout(()=>{e.on("fragment",e=>{a&&s(()=>({index:e.index,fragmentIndex:e.fragmentIndex}))})},0),window.addEventListener("storage",t=>{if(t.key===n&&t.oldValue&&t.newValue){const n=JSON.parse(t.oldValue),r=JSON.parse(t.newValue);if(n.index!==r.index||n.fragmentIndex!==r.fragmentIndex)try{a=!1,e.slide(r.index,{fragment:r.fragmentIndex})}finally{a=!0}}}),e.on("destroy",()=>{const{reference:e}=r();void 0===e||e<=1?b.remove(n):s(()=>({reference:e-1}))})}}function z(e={}){const t=Object.assign({slope:Math.tan(-35*Math.PI/180),swipeThreshold:30},e);return e=>{let n;const r=e.parent,s=e=>{const t=r.getBoundingClientRect();return{x:e.pageX-(t.left+t.right)/2,y:e.pageY-(t.top+t.bottom)/2}};r.addEventListener("touchstart",e=>{n=1===e.touches.length?s(e.touches[0]):void 0},{passive:!0}),r.addEventListener("touchmove",e=>{if(n)if(1===e.touches.length){e.preventDefault();const t=s(e.touches[0]),r=t.x-n.x,a=t.y-n.y;n.delta=Math.sqrt(Math.pow(Math.abs(r),2)+Math.pow(Math.abs(a),2)),n.radian=Math.atan2(r,a)}else n=void 0}),r.addEventListener("touchend",r=>{if(n){if(n.delta&&n.delta>=t.swipeThreshold){let s=n.radian-t.slope;s=(s+Math.PI)%(2*Math.PI)-Math.PI,e[s<0?"next":"prev"](),r.stopPropagation()}n=void 0}},{passive:!0})}}const H=[f.Normal,f.Presenter,f.Next];!function(r=document.getElementById("p")){document.body.setAttribute("data-bespoke-view",(()=>{switch(h("view")){case"next":return f.Next;case"presenter":return f.Presenter;default:return f.Normal}})());const i=(e=>{const t=h(e);return g({[e]:void 0}),t})("sync")||void 0,l=!1,u=!0,p=e(r,((...e)=>{const t=H.findIndex(e=>m()===e);if(t<0)throw new Error("Invalid view");return e.map(([e,n])=>e[t]&&n).filter(e=>e)})([[u,u,l],B({key:i})],[[u,u,u],V(r)],[[u,u,l],s],[[u,u,u],t],[[u,l,l],n()],[[u,u,u],a],[[u,u,u],Y({history:!1})],[[u,u,l],d()],[[u,u,l],c],[[u,l,l],X],[[u,u,l],z()],[[u,l,l],v()],[[u,u,u],o]));window.addEventListener("beforeunload",()=>g({sync:p.syncKey})),window.addEventListener("unload",()=>p.destroy())}()}();
</script></body></html>