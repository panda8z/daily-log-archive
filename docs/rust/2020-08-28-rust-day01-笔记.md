---

---
# 阅读《Rust权威指南》

- 一、入门指南
  - 安装 rustup 工具.
  - rustup 命令行工具.
  - rustc 命令行工具.
  - helloworld程序.
  - cargo 命令行工具.
  - rustup doc 本地文档入口.
  - rustup docs --book rust英文书.
- 二、编写一个猜数游戏
  - fn关键字.
  - main函数定义.
  - println!()方法使用.
  - 语句后要有分号.
  - {} 占位符.
  - let 关键字定义变量.
  - mut关键字定义可变变量.
  - use std::io 导入包.
  - :: 运算符 调用包方法 io::stdin().
  - String 类型.
  - Result类型和execpt()方法处理错误.
  - 使用 第三方库 rand.
  - cargo build 下载依赖包并编译.
  - cargo update 更新新版本依赖包.
  - cargo.lock文件锁定依赖包版本.
  - cargo run 编译并运行程序.
  - match表达式的基本使用.
  - 接触了 => 运算符,用于模式匹配.
  - loop {} 表达式做循环.
  - break语句结束循环.
- 三、通用编程概念
  - 变量, 用let关键字声明.
  - 可变性, 用 mut 关键字控制.
  - 标量类型 scalar.
  - 复合类型 compound.
  - 有符号整型 i8,i16,i32,i64,isize.
  - 无符号整型 u8,u16,u32,u64,usize.
  - 浮点型 f32, f64,遵循IEEE-754s
  - 整数字面量 76_000, 0xFDA9, 0o77, 0b1101_0011, b'A'.
  - 数值运算符 +, -, *, /, %.
  - 布尔类型 bool true false.
  - 字符类型 描述单个字符:‘a’ ‘5’ ‘*’ ‘¥’.
  - 元组 tuple 可放不同类型元素 定长 索引取值 (u8,i8,f32) (1,-2,3.0).
  - 数组 array 只能装同类型元素 定长 索引和迭代器取值 [1,2,3,4,5].
  - Rust使用蛇形命名法(snake case)规范函数和变量标识符.
  - 函数 用 fn 关键字定义 ,fn+函数名+参数列表+返回值列表+函数体.
  - 函数参数和返回值必须明确指定类型.
  - 函数参数是 parameters 中文叫形式参数.
  - 给函数传递具体值的时候的参数叫 arguments 中文叫实际参数.
  - 语句 statement 仅有操作没有返回值.
  - 表达式 expression 有具体计算后的值返回.
  - {} 可以定义一个代码块,也是个表达式,有返回值.
  - Rust默认最后一个表达式的值是函数返回值.
  - -> 运算符定义了 函数的返回值列表.
  - 注释,单行注释就是 // 文档注释在第十章才讲到.
  - if else表达式控制流: if+判断条件表达式+{} + else if + 判断条件 + {} + else + {}.
  - Rust提供三种循环: while loop 和 for
  - loop {} 无脑循环.
  - while + 判断条件 + {} 正常条件循环.
  - for item in list.iter() 集合遍历循环.
  - for - in 表达式集合遍历循环.
  - .. 表达式生成Range序列,(1..4)会生成一个序列目前不清楚是元组还是数组.
- 四、认识所有权
  - 所有权:rust核心概念之一, 影响深远,认真学习!
  - Rust 使用包含特定规则的所有权系统来管理内存分配和使用.
  - 编译器会在编译期发现并提出规避风险的措施.
  - 栈,先进后出的数据结构,摞盘子模型.
  - 堆,大块连续内存区域,管理比较松散,使用此区域前要分配不同大小的区域.
  - 计算机对堆的操作比栈的操作跟费时费力.
  - 所有权规则1:Rust中的每一个值都有一个对应的变量作为它的所有者.
  - 所有权规则2:在同一时间内,值有且仅有一个所有者.
  - 所有权规则3:当所有者离开自己的作用域时,它持有的值就会被释放掉.
  - 作用域是一个对象在程序中有效的范围.
  - 就目前知识而言: 代码块,函数结束就失去了作用域.
  - String类型是标准库提供的字符串数据类型.
  - let s = String::from(“Hello”) 创建新的不可变字符串变量.
  - let mut s = String::from(“Hello”) 创建新的可变字符串变量.
  - 就字符串字面量而言,编译期知道其具体大小所以在栈上分配.
  - 可变字符串变量,编译时未知其具体大小,所以在堆上分配.
  - 与有GC语言不同,Rust内存会自动地在拥有它的变量离开作用域后进行释放.
  - Rust会在作用域结束的地方自动调用 drop()函数.
  - 资源获取即初始化 Resource Acquisition Is Initialization RAII.
  - 变量和数据的交互方式: 移动 move.
  - Rust永远不会自动地创建数据地深度拷贝.
  - 变量和数据地交互方式: 克隆 clone.
  - 堆上地数据类型变量可以调用 clone() trait 产生新的堆分配变量.
  - 栈上变量和数据通过复制来交互 copy trait.
  - 将变量传递给函数将会触发移动或复制,就像是赋值语句一样.
  - 函数在返回值过程中也会发生所有权地转移.
  - 变量所有权转移的模式1: 将一个值赋值给另一个变量时就会转移所有权.
  - 变量所有权转移的模式2: 当一个持有堆数据的变量离开作用域时它的数据将会被 drop() 清理,除非这些数据的所有权发生了转移.
  - Rust提供了引用功能来简化所有权频繁更换的场景.
  - &s1 是String类型数据变量s1的引用
  - & 代表了引用予以,它允许在不获取所有权的前提下使用值.
  - 解引用 dereferencing,使用 * 运算符,15章详细介绍.
  - 对于特定作用域中的特定数据来说,一次只能使用一个可变引用.
  - 数据竞争 data race.
  - data race1: 两个或两个以上的指针同时访问同一空间.
  - data race2: 其中至少有一个指针会向空间中写入数据.
  - data race3: 没有同步数据访问的机制.
  - 任何数据竞争的情况出现在Rust里都编译不过.
  - 不能在拥有不可变引用的同时创建可变应用.
  - Rust的编译器会确保引用永远不会进入悬垂状态.
  - 新的概念 生命周期 会在 第10章详解.
  - 引用规则1: 在任何一段给定的时间里,要么只能拥有一个可变应用,要么只能拥有任意数量的不可变引用.
  - 引用规则2: 引用总是有效的.
  - 切片 `slice` Rust里面一个不持有所有权的数据类型.
  - 字符串切片的类型写作:&str
  - 还有很多其他类型的切片.&[i32] 数组切片.
  - 字符串字面量就是切片.
- 五、使用结构体来组织相关联的数据
  - 结构体,是一种自定义数据类型,它允许我们命名多个相关的值并将它们组成一个有机结合体.
  - 和元组一样,结构体中的的数据可以拥有不同类型.
  - 和元组不一样, 结构体需要给每个数据赋予名字以便清楚的表明它们的意义.
  - 关键字 `struct`定义结构体.
  - 通过点号来访问结构体实例中的特定字段.
  - 一旦实例可变,实例中的所有字段都将是可变的.
  - 结构体初始化支持 字段初始化简写 语法 field init shorthand.
  - 用类似元组的方式来定义元组结构体,不需要对字段命名.
  - Rust允许空结构体.后续章节会解释用法.
  - Rust独有的生命周期概念保证了结构体实例中引用数据的有效期不短于实例本身.
  - 分别用硬编码,元组,结构体实现长方形面积的求解程序.
  - 结构体可以定义方法.
  - 方法总被定义在某个结构体的上下文上.
  - `#[derive(Debug)]` 注解 让打印更人性化.
  - Rust有自动引用和解引用功能,直接用引用点元素就能访问数据.
  - 方法中的第一个参数 可能是 `self` 或 `&self` 表示结构体本身或起引用.
  - 不接受self参数的函数成文关联函数,association function,一般用于初始化结构体实例.
  - 所有方法被放在 关键字 `impl + 结构体名 + {}` 定义的代码块中.
  - 多个 `impl` 代码块可以同时存在.
- 六、枚举与模式匹配
  - 枚举类型,简称为枚举,它允许我们列举所有可能的值来定义一个类型.
  - 枚举中的元素被称为 枚举变体 variant.
  - 用 :`: 运算符访问枚举变体.
  - 枚举允许我们直接将其关联的数据嵌入枚举变体内.
  - IP相关的编码和操作标准库内置了一套开箱即用的定义.
  - 枚举同样可以使用 `impl` 关键字定义的代码块来添加方法.
  - 标准库中定义了一个枚举 Option 非常重要的核心概念.
  - Option类型描述了一种值可能不存在的情形,所以它广泛引用在各个地方.
  - 使用`option`概念的类型系统,可以让编译器自动检查我们是否妥善处理了所有应该被处理的情况.
  - 引发空值缺陷问的的关键不是空值概念本身,而是那些具体的实现措施.
  - \<T\> 是泛型参数, 第10章讨论其细节.
  - Rust中,无论在什么地方,只要一个值的类型不是 Option\<T\> 的,就可以安全假设其为非空.
  - match 表达式 是可以用来处理枚举的控制流结构.
  - match 表达式, 允许我们基于枚举拥有的变体来决定运行分支,并可通过模式匹配值来获取变体内数据.
