(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{356:function(a,t,e){"use strict";e.r(t);var n=e(42),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"（1）系列教程介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（1）系列教程介绍"}},[a._v("#")]),a._v(" （1）系列教程介绍")]),a._v(" "),e("p",[a._v("本文主要讲述如何使用CMakeLists.txt，配置程序的版本号。程序在发布的时候需要对用的版本号，同时为了保证程序的兼容性，往往需要在程序中判断当前程序的版本。所以如果在编译过程中将版本号自动的传入程序中，就可以使程序更智能。")]),a._v(" "),e("h2",{attrs:{id:"（2）cmake-的使用环境和安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（2）cmake-的使用环境和安装"}},[a._v("#")]),a._v(" （2）CMake 的使用环境和安装")]),a._v(" "),e("p",[a._v("本教程的使用环境为：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("ubutu18.04 lts\ngcc version 7.5.0\ng++ version 7.5.0\ncmake version 3.10.2\n")])])]),e("p",[a._v("安装cmake：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("sudo apt install cmake\n")])])]),e("h2",{attrs:{id:"（3）cmake配置版本号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（3）cmake配置版本号"}},[a._v("#")]),a._v(" （3）CMake配置版本号")]),a._v(" "),e("p",[a._v("在project命令中添加 VERSION 1.0 指令 就可以指定程序的版本。通过使用configure_file命令，解析TutorialConfig.h.in文件，将该版本号自动转换成宏定义额方式，传递到程序中。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('# 设置cmake的最低版本\ncmake_minimum_required(VERSION 3.10)\n\n# 设置工程名称 和版本\nproject(tutorial_second VERSION 1.0)\n\n# 指定版本号的配置文件\nconfigure_file(include/TutorialConfig.h.in TutorialConfig.h)\n\n# 增加生成可执行文件，生成的程序名称为：tutorial_first\nadd_executable(tutorial_second src/tutorial_second.cpp)\n\n# 为指定项目添加 include 路径\ntarget_include_directories(tutorial_second PUBLIC\n                            "${PROJECT_BINARY_DIR}"\n)\n')])])]),e("p",[a._v("命令使用：")]),a._v(" "),e("p",[a._v("configure_file：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("configure_file(<input> <output>\n   [COPYONLY] [ESCAPE_QUOTES] [@ONLY]\n   [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])\n")])])]),e("h2",{attrs:{id:"（4）使用cmake进行编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（4）使用cmake进行编译"}},[a._v("#")]),a._v(" （4）使用CMake进行编译")]),a._v(" "),e("p",[a._v("CMake在生成文件的过程中会生成很多中间缓存文件，为了是项目更简洁，文件路径更清楚，一般会在项目的root目录下建立一个文件夹，用于存储CMake生成的中间文件。而一般使用的文件家名称为build或者release。下面是使用命令：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("# 进入项目的root目录，本文为：tutorial_first\ncd tutorial_first\n\n# 创建存储缓存文件的文件夹，build\nmkdir build\n\n# 使用CMake命令生成makefile文件\ncmake ..\n\n# 使用make命令进行编译\ncmake --build .\n")])])]),e("h2",{attrs:{id:"（5）tutorialconfig-h-in中代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（5）tutorialconfig-h-in中代码"}},[a._v("#")]),a._v(" （5）TutorialConfig.h.in中代码")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// the configured options and settings for Tutorial\n#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@\n#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@\n")])])]),e("h2",{attrs:{id:"（6）cpp-代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#（6）cpp-代码"}},[a._v("#")]),a._v(" （6）cpp 代码")]),a._v(" "),e("p",[a._v("tutorial_second.cpp 程序代码：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('#include <iostream>\n#include "TutorialConfig.h"\n\nint main(int argc, char const *argv[])\n{\n    std::cout <<"第一个cmake教程" << std::endl;\n    if (argc < 2) {\n    // report version\n    std::cout << argv[0] << " Version " << Tutorial_VERSION_MAJOR << "."\n              << Tutorial_VERSION_MINOR << std::endl;\n    std::cout << "Usage: " << argv[0] << " number" << std::endl;\n\n  }\n    return 0;\n}\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);