<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Panda8z`Blog</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="Panda8z developer engineer designer">
    <link rel="preload" href="/assets/css/0.styles.d1974566.css" as="style"><link rel="preload" href="/assets/js/app.65df3687.js" as="script"><link rel="preload" href="/assets/js/2.4014e5fb.js" as="script"><link rel="preload" href="/assets/js/19.c8de6494.js" as="script"><link rel="prefetch" href="/assets/js/10.ef1fe66a.js"><link rel="prefetch" href="/assets/js/11.70e684ab.js"><link rel="prefetch" href="/assets/js/12.236fe0fe.js"><link rel="prefetch" href="/assets/js/13.bb84747e.js"><link rel="prefetch" href="/assets/js/14.cf0485b7.js"><link rel="prefetch" href="/assets/js/15.dc011595.js"><link rel="prefetch" href="/assets/js/16.043cd073.js"><link rel="prefetch" href="/assets/js/17.16279a29.js"><link rel="prefetch" href="/assets/js/18.d9303b40.js"><link rel="prefetch" href="/assets/js/20.b9094388.js"><link rel="prefetch" href="/assets/js/21.4cae9a48.js"><link rel="prefetch" href="/assets/js/3.f9625483.js"><link rel="prefetch" href="/assets/js/4.7e8a4869.js"><link rel="prefetch" href="/assets/js/5.87c78865.js"><link rel="prefetch" href="/assets/js/6.b8361db5.js"><link rel="prefetch" href="/assets/js/7.80b067b4.js"><link rel="prefetch" href="/assets/js/8.a8439088.js"><link rel="prefetch" href="/assets/js/9.205b9973.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d1974566.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://golang.google.cn/lib/godoc/images/go-logo-blue.svg" alt="Panda8z`Blog" class="logo"> <span class="site-name can-hide">Panda8z`Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Kinds" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/rust/" class="nav-link">
  Rust
</a></li><li class="dropdown-item"><!----> <a href="/cmake/" class="nav-link">
  CMake
</a></li><li class="dropdown-item"><!----> <a href="/技术面试/" class="nav-link">
  技术面试
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Kinds" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/rust/" class="nav-link">
  Rust
</a></li><li class="dropdown-item"><!----> <a href="/cmake/" class="nav-link">
  CMake
</a></li><li class="dropdown-item"><!----> <a href="/技术面试/" class="nav-link">
  技术面试
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/技术面试/字节面试01-后端.html" class="sidebar-link">字节面试01-后端</a></li><li><a href="/技术面试/字节面试02-java后端已入职.html" class="sidebar-link">字节面试02-java后端已入职</a></li><li><a href="/技术面试/字节面试03-后端.html" class="active sidebar-link">字节面试03-后端</a></li><li><a href="/技术面试/字节面试04-后端失败了.html" class="sidebar-link">字节面试04-后端失败了</a></li><li><a href="/技术面试/字节面试05-后端算法题.html" class="sidebar-link">字节面试05-后端算法题</a></li><li><a href="/技术面试/技术面试刷题指南.html" class="sidebar-link">技术面试刷题指南</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>​	&gt; <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1597839452&amp;ver=2532&amp;signature=g72xycorP712OxXuWyV8IVccuDD8O6wYzunDiymgzt8fshBYipK1AM6B83OxRMwn2sGaVFeSYACSJKluBHJWwov3EURMPKe-02zZ86fDrpNjfVk6YQpAYvZdUZcxTRwm&amp;new=1" target="_blank" rel="noopener noreferrer">我去字节跳动面试，“偷”回来的面试题，题真难...<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h1 id="算法题"><a href="#算法题" class="header-anchor">#</a> 算法题**</h1> <p>一面：</p> <p>\1. lc 里最长上升子序列的变形题</p> <p>\2. 实现输入英文单词联想的功能</p> <p>二面：</p> <p>1.矩阵旋转，要求空间复杂度 O(1)</p> <p>2.无序的数组的中位数。要求时间复杂度尽可能的小</p> <p><strong># 计算机网络</strong></p> <p>**
**</p> <p>\1. tcp 怎么保证数据包有序</p> <blockquote><ol><li><p>主机每次发送数据时，TCP 就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认。</p></li> <li><p>如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。</p></li> <li><p>接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等。</p></li> <li><p>接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p></li></ol></blockquote> <p>\2. tcp 和 udp 的异同</p> <blockquote><p>TCP 是面向流的可靠数据传输连接
UDP 是面向数据包的不可靠无连接</p></blockquote> <p>\3. tcp 怎么保证可靠性</p> <blockquote><p>差错检验机制，反馈机制，重传机制，引入序号，滑动窗口协议，选择重传</p></blockquote> <p>\4. tcp 中拥塞避免和流量控制机制</p> <blockquote><p>拥塞避免和流量控制这两种机制很像，但是流量控制是由接收方的接受能力也就是接收窗口所决定的，如果接收窗口够大，以动态调整发送窗口的大小调整发送速度
拥塞避免主要由网络情况所限制，网络情况良好，则加大发送速率，网络状态差（冗余 ACK 和丢包）则降低发送速率（慢启动，拥塞控制，快恢复，快重传） RENO，BBR</p></blockquote> <p>\5. tcp 四次挥手的详细解释</p> <blockquote><p>tcp 四次挥手其实可以分为两个阶段
第一：
客户端至服务器的半双工连接关闭
客户端向服务器发送 FIN 信号，进入 FIN_WAIT1 的状态，等待服务器的 ACK 信号
收到服务器的 ACK 后，进入 FIN_WAIT2
第二：
服务器至客户端的半双工连接关闭
客户端收到服务器发来的 FIN 后，发送 ACK，并进入 TIME_WAIT，等待 2msl，若无异常，则客户端认为连接成功关闭
服务器收到客户端发来的 ACK 后，关闭连接</p></blockquote> <p>\6. 四次挥手之后为什么还要等待 2msl</p> <blockquote><p>MSL 是报文最大生存时间
1 是因为有可能客户端发往服务器的 ACK 丢失，服务器并不知道客户端已经确认关闭，这时候客户端的关闭会导致服务器端无法正常关闭
2 是为了保证连接中的报文都已经传递。假如短时间关闭又重新实现一个 TCP 还连到了同个端口上，旧连接中尚未消失的数据就会被认为是新连接的数据。</p></blockquote> <p>\7. 浏览器从输入网址到显示出网页的全过程</p> <blockquote><p>\1. 输入网址或者 ip。
\2. 如果输入的是网址，首先要查找域名的 ip 地址
第一步会在浏览器缓存中查找，如果没有，转至查询系统缓存，如果还是没有，发送请求给路由器，路由器首先会在自身的缓存中查找，如果还是没有，向 ips 发出请求，查询 ips 中的 dns 缓存，如果还是没有递归向上查询直至根服务器。
\3. 浏览器与 ip 机器之间建立 TCP 连接（三次握手）（HTTP）或者在 TCP 上进一步建立 SSL/TLS 连接 （HTTPS）
接下来就是发送 HTTP 报文啥的了
GET，POST，DELETE，PUT。</p></blockquote> <p>\8. 滑动窗口机制的原理和理解</p> <blockquote><p>GBN 协议，回退 N 步协议，这是对停等协议的改进，因为停等协议的传输效率非常低下。每次可发送的数据为 N，基数为 base，小于 base 的数据已经发送并且确认，base 是最小的已发送未确认的报文序号。在接收端同样也有一个接收窗口，（解释）GBN采用的是累计确认方式，这时候说一下选择重传机制。再说一下 TCP 中既不是 GBN 也不是 SR ，而是 GBN 和 SR 的综合体。
N 的大小必须报文序列编号的一半，否则接收端对报文的确认可能发生混淆</p></blockquote> <p>\9. Https 原理和实现</p> <p>\10. cookie 和 session 的区别是什么</p> <blockquote><p>由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户
cookie 存在本地的上的
session 是存在服务器上的
通俗讲，Cookie 是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。另外一个更准确的说法是：Cookies 是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。
Session 是存在服务器的一种用来存放用户数据的类HashTable结构。
二者都用来保持用户的状态，cookie可更改，对服务器来说并不安全，服务器常见做法有这两种：
1.把 session 加密后放入浏览器的 cookie 中，浏览器重连后将加密的 session 发给服务器
2.cookie 中存储着 session的id，浏览器重连时只需要发送 session_id' 即可</p></blockquote> <p><strong># 操作系统</strong></p> <p>**
**</p> <p>\1. 进程和线程的区别</p> <blockquote><p>进程就是保存上下文切换的程序执行时间总和 = CPU 加载上下文 + CPU 执行 + CPU 保存上下文</p></blockquote> <p>\2. 线程是什么呢？</p> <blockquote><p>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：
程序 A 得到 CPU =》CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存 A 的上下文。
这里 a，b，c 的执行是共享了 A 的上下文， CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。</p></blockquote> <p>\3. 进程切换与线程切换</p> <p>\4. Linux 中五种 IO 模型</p> <blockquote><ol><li>阻塞 I/O（blocking I/O）</li> <li>非阻塞 I/O （nonblocking I/O）</li> <li>I/O 复用 (select 和poll) （I/O multiplexing）</li> <li>信号驱动 I/O （signal driven I/O (SIGIO)）</li> <li>异步 I/O （asynchronous I/O (the POSIX aio_functions)）
前四种都是同步，只有最后一种才是异步 IO。
同步 IO 和异步 IO 的区别就在于：数据拷贝的时候进程是否阻塞！
阻塞 IO 和非阻塞 IO 的区别就在于：应用程序的调用是否立即返回！</li></ol></blockquote> <p>\5. 如何实现一个同步非阻塞的请求</p> <p>\6. 实现进程同步的机制有什么</p> <p>\7. 信号量的实现机制</p> <p>\8. 共享锁和排他锁</p> <p>\9. 实现一个读写锁</p> <p>\10. 设计一个无锁队列</p> <p>\11. 协程的原理</p> <p><strong># 数据库</strong></p> <p>**
**</p> <p>\1. 索引是什么</p> <blockquote><p>索引 （Index） 是帮助 MySQL 高效获取数据的数据结构。</p> <ol><li>索引能极大的减少存储引擎需要扫描的数据量</li> <li>索引可以把随机 IO 变成顺序 IO</li> <li>索引可以帮助我们在进行 分组、 排序等操作时，避免使用临时表</li></ol></blockquote> <p>\2. 为什么要用 B+ 树（B+ 树的优缺点）</p> <blockquote><p>B+ 树是 B- 树的变种 （PLUS 版）多路绝对平衡查找树，好的时间复杂度
B+ 树扫库、表能力更强
B+ 树的磁盘读写能力更强
B+ 树的排序能力更强
B+ 树的查询效率更加稳定（仁者见仁、智者见智，有可能 B-Tree 第一次就命中了，直接返回，而 B+Tree 需要找到叶节点，所以查找效率不一定比 B-Tree 更高）
支持顺序排序，叶节点之间存在链接</p></blockquote> <p>\3. B+索引和哈希索引的区别？</p> <blockquote><p>B-tree 索引
索引是按照顺序存储的，所以，如果按照 B-tree 索引，可以直接返回，带顺序的数据，但这个数据只是该索引列含有的信息。因此是顺序 I/O
适用于：
精确匹配
范围匹配
最左匹配
Hash 索引
索引列值的哈希值+数据行指针：因此找到后还需要根据指针去找数据，造成随机I/O
适合：
精确匹配
不适合：
模糊匹配
范围匹配
不能排序
1、hash 索引仅满足 “=”、“IN” 和 “&lt;=&gt;” 查询，不能使用范围查询因为 hash 索引比较的是经常 hash 运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的 hash 值的大小关系，并不能保证与处理前的 hash 大小关系对应。
2、hash 索引无法被用来进行数据的排序操作由于 hash 索引中存放的都是经过hash 计算之后的值，而 hash 值的大小关系不一定与 hash 计算之前的值一样，所以数据库无法利用 hash 索引中的值进行排序操作。
3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比 B-Tree 索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。
总结：哈希适用在小范围的精确查找，在列数据很大，又不需要排序，不需要模糊查询，范围查询时有用</p></blockquote> <p>\4. B+ 树中叶子节点间的指针有什么用？</p> <blockquote><p>使得访问更加简单，b 树的话需要不断在父节点和叶子节点之间来回移动</p></blockquote> <p>\5. 聚簇和非聚簇索引的区别？</p> <blockquote><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，聚簇索引的叶子节点就是数据节点，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引，聚簇索引具有唯一性
非聚簇索引：非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</p></blockquote> <p>\6. 非聚簇索引的查询都要回表吗？</p> <blockquote><p>是的</p></blockquote> <p>\7. B+ 树和 AVL 树 B 树二叉搜索树有什么区别？</p> <blockquote><p>这几种各有交集但又不尽相同。
什么是二叉搜索树？
它或者是一棵空树，或者是具有下列性质的二叉树：
1.左子节点的值必定小于父节点的值
2.右子节点的值必定大于父节点的值
首先 AVL 树是自平衡的二叉搜索树AVL在该定义的基础上加入了平衡条件，即：某节点的左右子树的高度差小于等于1
另一种非严格自平衡的二叉搜索树是红黑树，二者使用场景略微有些不同。
AVL 追求整体的绝对平衡，适合于少量插入，大量查找的应用场景（因为维护全局平衡，插入一个往往需要 O(log n)）
红黑树适用于一部分插入，一部分查询的场景（变色，左旋右旋场景相对少些）
B+ 树是对 B 树的拓展
一棵 m 阶 B 树 (balanced tree of order m) 是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：
1、根结点至少有两个子女；
2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；
3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加 1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；
4、所有的叶子结点都位于同一层。
B+ 树对 B 树的改进就是：只有叶节点存数据，并且维护了两个指针，一个指向根节点另一个指向顺序叶节点的首位。
B+ 树还在叶子节点中加入了链接指针</p></blockquote> <p><strong># 杂项</strong></p> <p>**
**</p> <p>这一部分和项目比较相关。基本上项目中有什么或者面试官想到什么问什么，问了很多但是不通用。就只写一点。</p> <p>\1. GIL 是什么</p> <blockquote><p>全局状态锁</p></blockquote> <p>\2. 为什么会有?</p> <blockquote><p>出现多线程编程之间数据和状态一致性问题，为了解决这个数据不能同步的问题</p></blockquote> <p>\3. 有什么作用?</p> <p>\4. 怎么规避它对于并行的影响?</p> <p><strong># 语言相关</strong></p> <p>**
**</p> <p>\1. Python 的内存管理机制</p> <blockquote><p>（1）垃圾回收
（2）引用计数
（3）内存池机制</p></blockquote> <p>\2. 讲一下 Python GC 的原理和详细解释（分代，标记回收，内存划分）</p> <blockquote><p>Python 语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，『引用计数法』的原理是：每个对象维护一个 ob_ref  字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数 ob_ref 加 1，每当该对象的引用失效时计数 ob_ref 减 1，一旦对象的引用计数为 0，该对象立即被回收，对象占用的内存空间将被释放。
为了解决对象的循环引用问题，Python 引入了标记-清除和分代回收两种 GC 机制。
标记就是使用有向图的方式，不可达的清除掉（主要用来清理容器对象）
分代分为三代：年轻，中年，老年。年轻对象满，触发 GC，可回收对象回收掉，不可回收移到中年中去，以此类推。结合标记使用
引用计数增加
1.对象被创建：x=4
2.另外的别人被创建：y=x
3.被作为参数传递给函数：foo(x)
4.作为容器对象的一个元素：a=[1,x,'33']
引用计数减少
1.一个本地引用离开了它的作用域。比如上面的 foo(x) 函数结束时，x指向的对象引用减 1。
2.对象的别名被显式的销毁：del x ；或者 del y
3.对象的一个别名被赋值给其他对象：x=789
4.对象从一个窗口对象中移除：myList.remove(x)
5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。
垃圾回收
1、当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为 0 的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为 0 了。
2、垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象 ( a 引用 b, b 引用 a, 导致其引用计数永远不为 0)。</p></blockquote> <p>\3. Python 中 static_method 、 class_mathod 、和普通 method 有什么区别</p> <p>\4. 迭代器和生成器有什么区别？</p> <blockquote><p>先说结论，生成器式 一种特殊的迭代器：其在使用时生成。
首先明确两个概念：
Iterable ：所有实现了 iter__ 的对象均可称作 Iterablec。Iterator：是指同时实现了 <em>iter</em> 和 _next 的对象，迭代器也属于 Iterable。</p> <p>小结
凡是可作用于 for 循环的对象都是 Iterable 类型；
凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列</p></blockquote> <p>\5. 生成器怎么使用？</p> <p>两种方式：</p> <div class="language- extra-class"><pre class="language-text"><code>
a =(i for i in range(100))
def a(n):
    i = 0
    while(i &lt; n):
       yield i
       i += 1
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/技术面试/字节面试02-java后端已入职.html" class="prev">
        字节面试02-java后端已入职
      </a></span> <span class="next"><a href="/技术面试/字节面试04-后端失败了.html">
        字节面试04-后端失败了
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.65df3687.js" defer></script><script src="/assets/js/2.4014e5fb.js" defer></script><script src="/assets/js/19.c8de6494.js" defer></script>
  </body>
</html>
